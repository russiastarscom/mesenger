<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, height=device-height">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#6c5ce7">
    <meta name="format-detection" content="telephone=no">
    <title>Twin</title>
    <style>
        :root {
            --primary-color: #6c5ce7;
            --primary-dark: #5a4fcf;
            --danger-color: #e74c3c;
            --danger-dark: #c0392b;
            --success-color: #2ecc71;
            --success-dark: #27ae60;
            --text-color: #2d3436;
            --text-light: #636e72;
            --bg-color: #f8f9fa;
            --border-color: #e9ecef;
            --sent-message: #6c5ce7;
            --received-message: #ffffff;
            --message-hover: #f5f5f5;
            --modal-bg: #ffffff;
            --input-bg: #ffffff;
            --sidebar-bg: #f8f9fa;
            --header-bg: #ffffff;
            --online-color: #2ecc71;
            --offline-color: #e74c3c;
            --notification-bg: #6c5ce7;
            --notification-text: #ffffff;
            --channel-bg: #f0f3ff;
            --channel-hover: #e1e6ff;
            --shadow-light: 0 2px 10px rgba(0,0,0,0.05);
            --shadow-medium: 0 4px 15px rgba(0,0,0,0.1);
            --radius-small: 8px;
            --radius-medium: 12px;
            --radius-large: 16px;
            --primary-color: #6c5ce7;
            --primary-dark: #5a4fcf;
            --danger-color: #e74c3c;
            --danger-dark: #c0392b;
            --success-color: #2ecc71;
            --success-dark: #27ae60;
            --text-color: #2d3436;
            --text-light: #636e72;
            --bg-color: #f8f9fa;
            --border-color: #e9ecef;
            --sent-message: #6c5ce7;
            --received-message: #ffffff;
            --message-hover: #f5f5f5;
            --modal-bg: #ffffff;
            --input-bg: #ffffff;
            --sidebar-bg: #f8f9fa;
            --header-bg: #ffffff;
            --online-color: #2ecc71;
            --offline-color: #e74c3c;
            --notification-bg: #6c5ce7;
            --notification-text: #ffffff;
            --channel-bg: #f0f3ff;
            --channel-hover: #e1e6ff;
            --shadow-light: 0 2px 10px rgba(0,0,0,0.05);
            --shadow-medium: 0 4px 15px rgba(0,0,0,0.1);
            --radius-small: 8px;
            --radius-medium: 12px;
            --radius-large: 16px;
        }
        
        /* Темная тема */
        body.dark-theme {
            --bg-color: #1e1e1e;
            --text-color: #f0f0f0;
            --text-light: #b0b0b0;
            --border-color: #444444;
            --sent-message: #5a4fcf;
            --received-message: #2d2d2d;
            --message-hover: #333333;
            --modal-bg: #2d2d2d;
            --input-bg: #2d2d2d;
            --sidebar-bg: #1e1e1e;
            --header-bg: #2d2d2d;
            --notification-bg: #5a4fcf;
            --notification-text: #f0f0f0;
            --channel-bg: #2a2a4a;
            --channel-hover: #3a3a5a;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 100%;
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }
        
        .container {
            width: 100%;
            height: 100%;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s;
            -webkit-overflow-scrolling: touch;
        }
        
        .mobile-header {
            display: none;
            padding: 12px 15px;
            background: var(--primary-color);
            color: white;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .mobile-header h1 {
            font-size: 1.2rem;
            font-weight: 500;
        }
        
        .mobile-menu-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: var(--bg-color);
        }
        
        .post-section {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px 0;
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color);
        }
        
        .section-subtitle {
            color: var(--text-light);
            margin-bottom: 20px;
            font-size: 0.95rem;
        }
        
        .sidebar {
            width: 280px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            will-change: transform;
            -webkit-overflow-scrolling: touch;
            overflow-y: auto;
        }
        
        .user-profile {
            padding: 15px;
            background: var(--primary-color);
            color: white;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .user-profile h2 {
            margin-bottom: 5px;
            font-size: 1.2rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .user-emoji {
            font-size: 1.5rem;
            margin-right: 5px;
        }
        
        .user-profile p {
            font-size: 0.8rem;
            opacity: 0.9;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .connection-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 5px;
            background-color: var(--online-color);
        }
        
        .connection-status.offline {
            background-color: var(--offline-color);
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--sidebar-bg);
        }
        
        .tab {
            flex: 1;
            padding: 12px 0;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            font-size: 0.9rem;
            color: var(--text-light);
            transition: all 0.2s;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
        }
        
        .tab.active {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
        }
        
        .search-container {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--sidebar-bg);
        }
        
        .search-box {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.9rem;
            outline: none;
            background: var(--input-bg);
            color: var(--text-color);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        .search-results {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }
        
        .user-item {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            position: relative;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .user-item:active {
            background: var(--message-hover);
        }
        
        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .user-info {
            overflow: hidden;
            flex: 1;
        }
        
        .user-info h3 {
            font-size: 0.95rem;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
        }
        
        .user-emoji-small {
            font-size: 1rem;
            margin-right: 5px;
        }
        
        .user-info p {
            font-size: 0.8rem;
            color: var(--text-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .chat-preview {
            display: flex;
            flex-direction: column;
        }
        
        .chat-preview .last-message {
            font-size: 0.8rem;
            color: var(--text-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .chat-preview .last-time {
            font-size: 0.7rem;
            color: var(--text-light);
            align-self: flex-end;
        }
        
        .chat-actions {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .user-item:hover .chat-actions {
            opacity: 1;
        }
        
        .chat-action-btn {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            font-size: 1rem;
            padding: 2px;
            margin-left: 5px;
        }
        
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            min-height: 0;
            overflow: hidden;
        }
        
        .chat-header {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--header-bg);
            z-index: 10;
            flex-shrink: 0;
            position: sticky;
            top: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .chat-header-left {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 0;
        }
        
        .chat-header h2 {
            font-size: 1.1rem;
            font-weight: 500;
            margin-left: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .back-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            margin-right: 10px;
            display: none;
            cursor: pointer;
            color: var(--text-color);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .chat-header-actions {
            display: flex;
            gap: 8px;
        }
        
        .chat-header-btn {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 1rem;
            padding: 5px;
            border-radius: 50%;
            transition: background 0.2s;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .chat-header-btn:hover {
            background: var(--message-hover);
        }
        
        .chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            background: var(--bg-color);
            padding-bottom: 100px;
        }
        
        .message {
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .message.sent {
            align-items: flex-end;
        }
        
        .message.received {
            align-items: flex-start;
        }
        
        .message-content {
            max-width: 85%;
            padding: 10px 14px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
            line-height: 1.4;
            font-size: 0.95rem;
            overflow-wrap: break-word;
            word-break: break-word;
        }
        
        .message.sent .message-content {
            background: var(--sent-message);
            color: white;
            border-bottom-right-radius: 5px;
        }
        
        .message.received .message-content {
            background: var(--received-message);
            border-bottom-left-radius: 5px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .message-time {
            font-size: 0.7rem;
            color: var(--text-light);
            margin-top: 4px;
        }
        
        .message-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .message:hover .message-actions {
            opacity: 1;
        }
        
        .message-action-btn {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            font-size: 1rem;
            padding: 2px;
            margin-left: 5px;
        }
        
        .message-input {
            padding: 12px 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
            background: var(--header-bg);
            position: sticky;
            bottom: 0;
            z-index: 100;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            padding-bottom: max(12px, env(safe-area-inset-bottom));
        }
        
        .message-input input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.95rem;
            outline: none;
            background: var(--input-bg);
            color: var(--text-color);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        .message-input button {
            margin-left: 8px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .message-input button:active {
            background: var(--primary-dark);
        }
        
        .message-input-wrapper {
            display: flex;
            align-items: flex-end;
            width: 100%;
            gap: 8px;
        }
        
        .message-textarea {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.95rem;
            outline: none;
            background: var(--input-bg);
            color: var(--text-color);
            resize: none;
            min-height: 40px;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        .message-textarea:focus {
            border-color: var(--primary-color);
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .message-textarea {
                padding: 12px 15px;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 44px;
            }
            
            .message-input button {
                width: 44px;
                height: 44px;
            }
        }
        
        @media (max-width: 480px) {
            .message-textarea {
                padding: 10px 14px;
                font-size: 16px;
                min-height: 42px;
            }
            
            .message-input button {
                width: 42px;
                height: 42px;
            }
        }
        
        /* Additional mobile touch optimizations */
        @media (max-width: 768px) {
            .message-input {
                padding: 10px;
                padding-bottom: max(10px, env(safe-area-inset-bottom));
            }
        }
        
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--text-light);
            padding: 20px;
            text-align: center;
        }
        
        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 15px;
            opacity: 0.3;
        }
        
        .empty-state h3 {
            margin-bottom: 8px;
            font-size: 1.2rem;
            font-weight: 500;
        }
        
        .empty-state p {
            font-size: 0.9rem;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--notification-bg);
            color: var(--notification-text);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            max-width: 90%;
            text-align: center;
        }
        
        .notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        /* Telegram-style toast notifications */
        .toast-notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 380px;
            width: calc(100% - 40px);
            pointer-events: none;
        }
        
        .toast-notification {
            background: var(--modal-bg);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.1);
            padding: 14px 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            pointer-events: all;
            transform: translateX(120%);
            opacity: 0;
            transition: all 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        .toast-notification.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .toast-notification.hiding {
            transform: translateX(120%);
            opacity: 0;
        }
        
        .toast-notification:hover {
            transform: translateX(0) scale(1.02);
            box-shadow: 0 12px 40px rgba(0,0,0,0.2), 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .toast-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
            overflow: hidden;
        }
        
        .toast-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .toast-content {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .toast-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .toast-title {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .toast-time {
            font-size: 0.75rem;
            color: var(--text-light);
            flex-shrink: 0;
        }
        
        .toast-message {
            font-size: 0.85rem;
            color: var(--text-light);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            word-break: break-word;
        }
        
        .toast-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: transparent;
            color: var(--text-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.2s;
            padding: 0;
        }
        
        .toast-notification:hover .toast-close {
            opacity: 1;
        }
        
        .toast-close:hover {
            background: var(--message-hover);
            color: var(--text-color);
        }
        
        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--primary-color);
            border-radius: 0 0 0 12px;
            transition: width 0.1s linear;
        }
        
        .toast-notification.group .toast-avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .toast-notification.channel .toast-avatar {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        /* Professional Post Text Field Styles */
        .post-field-container {
            position: relative;
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-medium);
            background: var(--input-bg);
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-light);
            margin: 20px 0;
        }

        .post-field-container:focus-within {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.1);
        }

        .post-field-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(108, 92, 231, 0.02);
        }

        .post-field-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .post-field-placeholder {
            color: var(--text-light);
            font-size: 0.95rem;
            flex: 1;
        }

        .post-field-textarea {
            width: 100%;
            min-height: 120px;
            padding: 20px;
            border: none;
            resize: none;
            outline: none;
            font-family: inherit;
            font-size: 1rem;
            line-height: 1.5;
            background: transparent;
            color: var(--text-color);
        }

        .post-field-textarea::placeholder {
            color: var(--text-light);
            opacity: 0.7;
        }

        .post-field-actions {
            padding: 15px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(108, 92, 231, 0.02);
        }

        .post-field-tools {
            display: flex;
            gap: 15px;
        }

        .post-field-tool {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            font-size: 1.1rem;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-field-tool:hover {
            color: var(--primary-color);
            background: rgba(108, 92, 231, 0.1);
        }

        .post-field-button {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            padding: 10px 20px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .post-field-button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .post-field-button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
            transform: none;
        }

        .character-counter {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 5px;
            text-align: right;
        }

        /* Responsive styles for post field */
        @media (max-width: 768px) {
            .post-field-header {
                padding: 12px 15px;
            }

            .post-field-textarea {
                padding: 15px;
                min-height: 100px;
            }

            .post-field-actions {
                padding: 12px 15px;
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .post-field-tools {
                justify-content: center;
            }

            .post-field-button {
                width: 100%;
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .post-field-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .post-field-tools {
                width: 100%;
                justify-content: space-around;
            }
        }
        
        /* Compact version of post field */
        .post-field-compact {
            border-radius: var(--radius-small);
        }

        .post-field-compact .post-field-textarea {
            min-height: 80px;
            padding: 15px;
        }

        .post-field-compact .post-field-header,
        .post-field-compact .post-field-actions {
            padding: 10px 15px;
        }
        
        @media (max-width: 768px) {
            .toast-notification-container {
                top: auto;
                bottom: 20px;
                right: 10px;
                left: 10px;
                width: calc(100% - 20px);
                max-width: none;
            }
            
            .toast-notification {
                padding: 12px 14px;
            }
            
            .toast-avatar {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
            
            .toast-title {
                font-size: 0.9rem;
            }
            
            .toast-message {
                font-size: 0.8rem;
            }
        }
        
        .settings {
            padding: 12px;
            border-top: 1px solid var(--border-color);
            position: sticky;
            bottom: 0;
            background: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .settings-btn {
            width: calc(100% - 24px);
            margin: 0 12px;
            padding: 10px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.9rem;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .settings-btn:active {
            background: var(--primary-dark);
        }
        
        .logout-btn {
            width: calc(100% - 24px);
            margin: 0 12px;
            padding: 10px;
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.9rem;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .logout-btn:active {
            background: var(--danger-dark);
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            padding: 16px;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background: var(--modal-bg);
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            transform: translateY(20px);
            transition: transform 0.3s ease;
            color: var(--text-color);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal.active .modal-content {
            transform: translateY(0) translateZ(0);
        }
        
        .modal-title {
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.2rem;
        }
        
        .modal-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 1rem;
            background: var(--input-bg);
            color: var(--text-color);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
        }
        
        .modal-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.95rem;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .modal-btn-primary {
            background: var(--primary-color);
            color: white;
        }
        
        .modal-btn-secondary {
            background: var(--border-color);
            color: var(--text-color);
        }
        
        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .theme-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .theme-toggle input {
            margin-right: 10px;
        }
        
        .emoji-selector {
            margin-bottom: 15px;
        }
        
        .emoji-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .emoji-option {
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        .emoji-option:hover {
            background: var(--message-hover);
        }
        
        .emoji-option.selected {
            background: var(--primary-color);
            color: white;
        }
        
        .group-participants {
            margin-bottom: 15px;
        }
        
        .participants-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .participant-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .participant-item:last-child {
            border-bottom: none;
        }
        
        .participant-checkbox {
            margin-right: 10px;
        }
        
        .blocked-users {
            margin-top: 15px;
        }
        
        .blocked-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .blocked-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .blocked-item:last-child {
            border-bottom: none;
        }
        
        .unblock-btn {
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        /* Стили для каналов */
        .channel-item {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            position: relative;
            background: var(--channel-bg);
        }
        
        .channel-item:active {
            background: var(--channel-hover);
        }
        
        .channel-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: bold;
            flex-shrink: 0;
            font-size: 1.2rem;
            overflow: hidden;
        }
        
        .channel-icon iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 50%;
        }
        
        .channel-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .channel-icon-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px auto;
            font-weight: bold;
            font-size: 1.5rem;
            overflow: hidden;
        }
        
        .channel-icon-preview iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 50%;
        }
        
        .channel-icon-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .channel-icon-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .channel-icon-item:last-child {
            border-bottom: none;
        }
        
        .channel-icon-display {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary-color);
        }
        
        .channel-icon-display iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 50%;
        }
        
        .channel-icon-url {
            flex: 1;
            margin: 0 10px;
            font-size: 0.8rem;
            color: var(--text-light);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .delete-icon-btn {
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .channel-info {
            overflow: hidden;
            flex: 1;
        }
        
        .channel-info h3 {
            font-size: 0.95rem;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
        }
        
        .channel-info p {
            font-size: 0.8rem;
            color: var(--text-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .channel-subscribers {
            font-size: 0.7rem;
            color: var(--text-light);
            display: flex;
            align-items: center;
        }
        
        .subscribe-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .subscribe-btn:active {
            background: var(--primary-dark);
        }
        
        .subscribe-btn.subscribed {
            background: var(--text-light);
            color: var(--text-color);
        }
        
        /* Стили для меню настроек */
        .settings-menu {
            display: none;
            position: fixed;
            bottom: 100px;
            right: 20px;
            background: var(--modal-bg);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 200px;
            overflow: hidden;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .settings-menu.active {
            display: block;
            transform: translateY(0);
            opacity: 1;
        }
        
        .settings-menu-item {
            padding: 12px 15px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .settings-menu-item:hover {
            background: var(--message-hover);
        }
        
        .settings-menu-item.create-group {
            color: var(--success-color);
        }
        
        .settings-menu-item.create-channel {
            color: var(--primary-color);
        }
        
        .settings-menu-item.logout {
            color: var(--danger-color);
        }
        
        @media (max-width: 768px) {
            .mobile-header {
                display: flex;
                padding-top: max(12px, env(safe-area-inset-top));
                min-height: 56px;
            }
            
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                z-index: 200;
                transform: translateX(-100%);
                width: 85%;
                max-width: 320px;
                min-width: 260px;
                height: 100%;
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                transition: transform 0.3s ease;
            }
            
            .sidebar.active {
                transform: translateX(0);
                box-shadow: 4px 0 20px rgba(0,0,0,0.3);
            }
            
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 199;
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .sidebar-overlay.active {
                display: block;
                opacity: 1;
            }
            
            .back-btn {
                display: block;
            }
            
            .chat-header h2 {
                max-width: 200px;
            }
            
            .message-content {
                max-width: 80%;
            }
            
            .message-input {
                padding: 10px;
                padding-bottom: max(10px, env(safe-area-inset-bottom));
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
            }
            
            .message-input input {
                padding: 12px 15px;
                font-size: 16px;
                min-height: 44px;
            }
            
            .message-input button {
                width: 44px;
                height: 44px;
            }
            
            .chat-messages {
                padding: 12px;
                padding-bottom: calc(80px + env(safe-area-inset-bottom));
            }
            
            .settings-menu {
                bottom: calc(90px + env(safe-area-inset-bottom));
                right: 10px;
                width: 180px;
            }
            
            .user-profile {
                padding-top: max(15px, env(safe-area-inset-top));
            }
            
            .settings {
                padding-bottom: max(12px, env(safe-area-inset-bottom));
            }
        }
        
        @media (max-width: 480px) {
            .user-profile {
                padding: 12px 10px;
                padding-top: max(12px, env(safe-area-inset-top));
            }
            
            .user-profile h2 {
                font-size: 1.1rem;
            }
            
            .chat-messages {
                padding: 10px;
                padding-bottom: calc(90px + env(safe-area-inset-bottom));
            }
            
            .message-content {
                max-width: 90%;
                padding: 10px 14px;
                font-size: 1rem;
            }
            
            .message-input {
                padding: 8px 10px;
                padding-bottom: max(8px, env(safe-area-inset-bottom));
                gap: 8px;
            }
            
            .message-input input {
                padding: 10px 14px;
                font-size: 16px;
                min-height: 42px;
            }
            
            .message-input button {
                width: 42px;
                height: 42px;
            }
            
            .chat-header {
                padding: 10px 12px;
                min-height: 52px;
                padding-top: max(10px, env(safe-area-inset-top));
            }
            
            .chat-header h2 {
                font-size: 0.95rem;
                max-width: 150px;
                margin-left: 8px;
            }
            
            .back-btn {
                font-size: 1.3rem;
                padding: 6px;
                margin-right: 5px;
            }
            
            .chat-header-btn {
                padding: 6px;
                font-size: 1rem;
            }
            
            .user-avatar {
                width: 32px;
                height: 32px;
                font-size: 0.9rem;
            }
            
            .chat-header-actions {
                gap: 4px;
            }
            
            .modal-content {
                width: 95%;
                padding: 16px;
            }
            
            .modal-title {
                font-size: 1.1rem;
            }
            
            .modal-input {
                padding: 10px;
                font-size: 16px;
            }
            
            .modal-btn {
                padding: 12px;
                font-size: 0.95rem;
            }
            
            .user-item {
                padding: 10px 12px;
            }
            
            .user-info h3 {
                font-size: 0.9rem;
            }
            
            .user-info p {
                font-size: 0.75rem;
            }
            
            .tab {
                padding: 10px 0;
                font-size: 0.85rem;
            }
            
            .search-box {
                padding: 8px 12px;
                font-size: 16px;
            }
            
            .settings-btn, .logout-btn {
                padding: 12px;
                font-size: 0.9rem;
            }
            
            .empty-state h3 {
                font-size: 1.1rem;
            }
            
            .empty-state p {
                font-size: 0.85rem;
            }
            
            .empty-state svg {
                width: 60px;
                height: 60px;
            }
            
            .notification {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            
            .message {
                margin-bottom: 8px;
            }
            
            .message-time {
                font-size: 0.65rem;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 360px) {
            .sidebar {
                width: 90%;
                min-width: 240px;
            }
            
            .chat-header h2 {
                font-size: 0.9rem;
                max-width: 120px;
            }
            
            .message-content {
                max-width: 92%;
                padding: 8px 12px;
                font-size: 0.95rem;
            }
            
            .user-avatar {
                width: 28px;
                height: 28px;
                font-size: 0.8rem;
            }
            
            .chat-header-btn {
                padding: 5px;
                font-size: 0.9rem;
            }
        }
        
        /* Landscape mode on mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .mobile-header {
                min-height: 44px;
                padding-top: 8px;
                padding-bottom: 8px;
            }
            
            .chat-header {
                min-height: 44px;
                padding-top: 8px;
                padding-bottom: 8px;
            }
            
            .chat-messages {
                padding-bottom: 70px;
            }
            
            .message-input {
                padding: 6px 10px;
            }
            
            .message-input input {
                min-height: 38px;
            }
            
            .message-input button {
                width: 38px;
                height: 38px;
            }
            
            .sidebar {
                padding-top: 8px;
            }
            
            .user-profile {
                padding: 10px;
            }
        }
        
        /* Стили для звонков */
        .call-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .call-modal.active {
            display: flex;
            opacity: 1;
        }
        
        .call-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .call-header {
            text-align: center;
            color: white;
            padding-top: 40px;
        }
        
        .call-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
            font-size: 3rem;
            font-weight: bold;
        }
        
        .call-name {
            font-size: 1.5rem;
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        .call-status {
            font-size: 1rem;
            opacity: 0.8;
            color: #aaa;
        }
        
        .call-videos {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin: 20px 0;
        }
        
        .call-video-remote {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
            object-fit: cover;
            border-radius: 12px;
            background: #000;
        }
        
        .call-video-local {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 200px;
            object-fit: cover;
            border-radius: 12px;
            background: #000;
            border: 2px solid white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .call-audio-only {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        .call-audio-icon {
            font-size: 5rem;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .call-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding-bottom: 40px;
        }
        
        .call-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .call-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        
        .call-btn:active {
            transform: scale(0.95);
        }
        
        .call-btn-end {
            background: var(--danger-color);
            width: 70px;
            height: 70px;
            transform: rotate(135deg);
        }
        
        .call-btn-end:hover {
            background: var(--danger-dark);
        }
        
        .call-btn-accept {
            background: var(--success-color);
            width: 70px;
            height: 70px;
        }
        
        .call-btn-accept:hover {
            background: var(--success-dark);
        }
        
        .call-btn.muted {
            background: var(--danger-color);
        }
        
        .call-btn.video-off {
            background: var(--danger-color);
        }
        
        /* Стили для системы подарков */
        .gift-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .gift-item:last-child {
            border-bottom: none;
        }
        
        .gift-icon {
            font-size: 1.5rem;
            margin-right: 10px;
        }
        
        .gift-info {
            flex: 1;
        }
        
        .gift-sender {
            font-weight: bold;
        }
        
        .gift-date {
            font-size: 0.8rem;
            color: var(--text-light);
        }
        
        .user-profile-info {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .user-profile-info .user-avatar {
            width: 80px;
            height: 80px;
            font-size: 2.5rem;
            margin: 0 auto 10px;
        }
        
        .user-profile-info h3 {
            margin: 5px 0;
            font-size: 1.3rem;
        }
        
        .user-profile-info p {
            margin: 3px 0;
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .user-gifts-section h3 {
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .gifts-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .gift-actions {
            display: flex;
            gap: 5px;
        }
        
        .gift-action-btn {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            font-size: 1rem;
            padding: 2px;
            margin-left: 5px;
        }
        
        .gift-action-btn:hover {
            color: var(--primary-color);
        }
        
        /* Improved profile viewing styles */
        .user-profile-info {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 25px;
            margin: -20px -20px 20px -20px;
        }
        
        .user-profile-info .user-avatar {
            width: 120px;
            height: 120px;
            font-size: 3.5rem;
            margin: 0 auto 15px;
            background: rgba(255, 255, 255, 0.2);
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .user-profile-info h3 {
            margin: 10px 0;
            font-size: 1.8rem;
            font-weight: bold;
        }
        
        .user-profile-info p {
            margin: 5px 0;
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .user-gifts-section h3 {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
        }
        
        .gifts-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
        }
        
        .gift-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
        }
        
        .gift-item:last-child {
            margin-bottom: 0;
        }
        
        .gift-icon {
            font-size: 2.5rem;
            margin-right: 15px;
        }
        
        .gift-info {
            flex: 1;
        }
        
        .gift-sender {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 3px;
        }
        
        .gift-date {
            font-size: 0.85rem;
            color: var(--text-light);
        }
        
        /* Gift marketplace styles */
        .gift-types-container {
            margin: 15px 0;
        }
        
        .gift-type-item {
            background: var(--input-bg);
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 15px;
            border: 1px solid var(--border-color);
        }
        
        .gift-buy-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .gift-buy-btn:hover {
            background: var(--primary-dark);
        }
        
        @media (max-width: 768px) {
            .call-video-local {
                width: 100px;
                height: 133px;
                bottom: 10px;
                right: 10px;
            }
            
            .call-avatar {
                width: 80px;
                height: 80px;
                font-size: 2.5rem;
            }
            
            .call-name {
                font-size: 1.3rem;
            }
            
            .call-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            
            .call-btn-end,
            .call-btn-accept {
                width: 60px;
                height: 60px;
            }
            
            .call-controls {
                gap: 20px;
                padding-bottom: 30px;
            }
        }
    </style>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
</head>
<body>
    <div class="container">
        <div class="mobile-header">
            <button class="mobile-menu-btn" id="menu-btn">☰</button>
            <h1 id="mobile-title">Twin</h1>
            <div style="width: 24px;"></div>
        </div>
        
        <div class="sidebar-overlay" id="sidebar-overlay"></div>
        
        <div class="content-wrapper">
            <div class="main-content" id="main-content" style="display: none;">
                <div class="post-section">
                    <h2 class="section-title">Create a Post</h2>
                    <p class="section-subtitle">Share your thoughts with your network</p>
                    
                    <!-- Professional Post Text Field -->
                    <div class="post-field-container">
                        <div class="post-field-header">
                            <div class="post-field-avatar" id="post-user-avatar">U</div>
                            <div class="post-field-placeholder">What's on your mind?</div>
                        </div>
                        <textarea class="post-field-textarea" placeholder="Write your post here..."></textarea>
                        <div class="post-field-actions">
                            <div class="post-field-tools">
                                <button class="post-field-tool" title="Add poll">📊</button>
                                <button class="post-field-tool" title="Tag people">👤</button>
                                <button class="post-field-tool" title="Add feeling">😊</button>
                            </div>
                            <button class="post-field-button" id="publish-post-btn">Publish</button>
                        </div>
                        <div class="character-counter"><span id="post-char-count">0</span>/500</div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar" id="sidebar">
                <div class="user-profile">
                    <h2 id="current-user">
                        <span class="user-emoji" id="user-emoji">😊</span>
                        <span>Загрузка...</span>
                    </h2>
                    <p>
                        Онлайн
                        <span class="connection-status" id="connection-status"></span>
                    </p>
                </div>
                
                <div class="tabs">
                    <button class="tab active" id="chats-tab">Чаты</button>
                    <button class="tab" id="users-tab">Пользователи</button>
                    <button class="tab" id="channels-tab">Каналы</button>
                </div>
                
                <div class="search-container">
                    <input type="text" class="search-box" id="search-input" placeholder="Поиск по юзернейму...">
                </div>
                
                <div class="search-results" id="search-results">
                    <!-- Результаты поиска будут здесь -->
                </div>
                
                <div class="settings">
                    <button class="settings-btn" id="profile-settings-btn">Настройки профиля</button>          
                    <button class="settings-btn" id="settings-btn">Настройки</button>
                    <button class="logout-btn" id="logout-btn">Выйти</button>
                </div>
            </div>
            
            <div class="chat-area">
                <div class="empty-state" id="empty-state">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                    <h3>Выберите чат</h3>
                    <p>Найдите пользователя и начните общение</p>
                </div>
                
                <div class="chat-header" id="chat-header" style="display: none;">
                    <div class="chat-header-left">
                        <button class="back-btn" id="back-btn">←</button>
                        <div class="user-avatar" id="chat-avatar">?</div>
                        <h2 id="chat-user-name">
                            <span class="user-emoji-small" id="chat-user-emoji">😊</span>
                            <span>Пользователь</span>
                        </h2>
                    </div>
                    <div class="chat-header-actions">
                        <button class="chat-header-btn" id="close-chat-btn" title="Вернуться к списку чатов">←</button>
                        <button class="chat-header-btn" id="view-profile-btn" title="Просмотр профиля">👤</button>
                        <button class="chat-header-btn" id="send-gift-btn" title="Отправить подарок">🌹</button>
                        <button class="chat-header-btn" id="block-user-btn" title="Заблокировать пользователя">🚫</button>
                        <button class="chat-header-btn" id="delete-chat-btn" title="Удалить чат">🗑️</button>
                        <button class="chat-header-btn" id="group-settings-btn" title="Настройки группы" style="display: none;">⚙️</button>
                        <button class="chat-header-btn" id="channel-settings-btn" title="Настройки канала" style="display: none;">⚙️</button>
                    </div>
                </div>
                
                <div class="chat-messages" id="chat-messages" style="display: none;">
                    <!-- Сообщения будут здесь -->
                </div>
                
                <div class="message-input" id="message-input-container" style="display: none;">
                    <div class="message-input-wrapper">
                        <textarea id="message-text" class="message-textarea" placeholder="Введите сообщение..." autocomplete="off"></textarea>
                        <button id="send-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Меню настроек -->
    <div class="settings-menu" id="settings-menu">
        <div class="settings-menu-item create-group" id="create-group-menu-btn">
            <span>👥</span>
            <span>Создать группу</span>
        </div>
        <div class="settings-menu-item create-channel" id="create-channel-menu-btn">
            <span>📢</span>
            <span>Создать канал</span>
        </div>
        <div class="settings-menu-item logout" id="logout-menu-btn">
            <span>🚪</span>
            <span>Выйти</span>
        </div>
    </div>
    
    <!-- Модальное окно уведомлений -->
    <div class="notification" id="notification"></div>
    
    <!-- Telegram-style toast notifications container -->
    <div class="toast-notification-container" id="toast-container"></div>
    
    <!-- Модальное окно настроек -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <h2 class="modal-title">Настройки</h2>
            
            <div class="theme-toggle">
                <label>
                    <input type="checkbox" id="theme-toggle">
                    <span>Темная тема</span>
                </label>
            </div>
            
            <div class="theme-toggle" id="notification-toggle-container">
                <label>
                    <input type="checkbox" id="notification-toggle">
                    <span>Уведомления в браузере</span>
                </label>
            </div>
            <div id="notification-status" style="font-size: 0.8rem; color: var(--text-light); margin-bottom: 10px; display: none;"></div>
            <button class="modal-btn modal-btn-secondary" id="test-notification-btn" style="width: 100%; margin-bottom: 15px; display: none;">Проверить уведомления</button>
            
            <div class="emoji-selector">
                <label>Ваш статус:</label>
                <div class="emoji-options" id="emoji-options">
                    <span class="emoji-option" data-emoji="😊">😊</span>
                    <span class="emoji-option" data-emoji="😎">😎</span>
                    <span class="emoji-option" data-emoji="🤔">🤔</span>
                    <span class="emoji-option" data-emoji="😴">😴</span>
                    <span class="emoji-option" data-emoji="😢">😢</span>
                    <span class="emoji-option" data-emoji="😡">😡</span>
                    <span class="emoji-option" data-emoji="🥳">🥳</span>
                    <span class="emoji-option" data-emoji="😍">😍</span>
                </div>
            </div>
            
            <div class="blocked-users">
                <label>Заблокированные пользователи:</label>
                <div class="blocked-list" id="blocked-list">
                    <!-- Список заблокированных пользователей -->
                </div>
            </div>
            
            <input type="text" class="modal-input" id="new-username-input" placeholder="Новый никнейм">
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-settings-btn">Отмена</button>
                <button class="modal-btn modal-btn-primary" id="save-settings-btn">Сохранить</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно настроек профиля -->
    <div class="modal" id="profile-settings-modal">
        <div class="modal-content">
            <h2 class="modal-title">Настройки профиля</h2>
            
            <input type="text" class="modal-input" id="profile-username-input" placeholder="Ваше имя">
            
            <div class="emoji-selector">
                <label>Ваш статус:</label>
                <div class="emoji-options" id="profile-emoji-options">
                    <span class="emoji-option" data-emoji="😊">😊</span>
                    <span class="emoji-option" data-emoji="😎">😎</span>
                    <span class="emoji-option" data-emoji="🤔">🤔</span>
                    <span class="emoji-option" data-emoji="😴">😴</span>
                    <span class="emoji-option" data-emoji="😢">😢</span>
                    <span class="emoji-option" data-emoji="😡">😡</span>
                    <span class="emoji-option" data-emoji="🥳">🥳</span>
                    <span class="emoji-option" data-emoji="😍">😍</span>
                </div>
            </div>
            
            <div class="user-gifts-section">
                <h3>Мои полученные подарки</h3>
                <div class="gifts-list" id="my-gifts-list">
                    <!-- Список моих подарков будет здесь -->
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-profile-settings-btn">Отмена</button>
                <button class="modal-btn modal-btn-primary" id="save-profile-settings-btn">Сохранить</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно создания группы -->
    <div class="modal" id="create-group-modal">
        <div class="modal-content">
            <h2 class="modal-title">Создание группы</h2>
            
            <input type="text" class="modal-input" id="group-name-input" placeholder="Название группы">
            
            <div class="group-participants">
                <label>Участники группы:</label>
                <div class="participants-list" id="participants-list">
                    <!-- Список участников -->
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-group-btn">Отмена</button>
                <button class="modal-btn modal-btn-primary" id="create-group-confirm-btn">Создать</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно создания канала -->
    <div class="modal" id="create-channel-modal">
        <div class="modal-content">
            <h2 class="modal-title">Создание канала</h2>
            
            <input type="text" class="modal-input" id="channel-name-input" placeholder="Название канала">
            <textarea class="modal-input" id="channel-description-input" rows="3" placeholder="Описание канала"></textarea>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-channel-btn">Отмена</button>
                <button class="modal-btn modal-btn-primary" id="create-channel-confirm-btn">Создать</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно редактирования сообщения -->
    <div class="modal" id="edit-message-modal">
        <div class="modal-content">
            <h2 class="modal-title">Редактирование сообщения</h2>
            <textarea class="modal-input" id="edit-message-text" rows="3" placeholder="Текст сообщения"></textarea>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-edit-btn">Отмена</button>
                <button class="modal-btn modal-btn-primary" id="save-edit-btn">Сохранить</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно настроек группы -->
    <div class="modal" id="group-settings-modal">
        <div class="modal-content">
            <h2 class="modal-title">Настройки группы</h2>
            
            <input type="text" class="modal-input" id="edit-group-name-input" placeholder="Название группы">
            
            <div class="group-participants">
                <label>Участники группы:</label>
                <div class="participants-list" id="edit-participants-list">
                    <!-- Список участников -->
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-group-settings-btn">Отмена</button>
                <button class="modal-btn modal-btn-primary" id="save-group-settings-btn">Сохранить</button>
                <button class="modal-btn" id="leave-group-btn" style="background: var(--danger-color); color: white;">Покинуть группу</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно настроек канала -->
    <div class="modal" id="channel-settings-modal">
        <div class="modal-content">
            <h2 class="modal-title">Настройки канала</h2>
            
            <input type="text" class="modal-input" id="edit-channel-name-input" placeholder="Название канала">
            <textarea class="modal-input" id="edit-channel-description-input" rows="3" placeholder="Описание канала"></textarea>
            
            <button class="modal-btn modal-btn-primary" id="manage-channel-icons-btn" style="width: 100%; margin-bottom: 15px; display: none;">Управление иконками</button>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-channel-settings-btn">Отмена</button>
                <button class="modal-btn modal-btn-primary" id="save-channel-settings-btn">Сохранить</button>
                <button class="modal-btn" id="unsubscribe-channel-btn" style="background: var(--danger-color); color: white;">Отписаться</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно управления иконками канала (только для админа) -->
    <div class="modal" id="channel-icons-modal">
        <div class="modal-content">
            <h2 class="modal-title">Управление иконками канала</h2>
            
            <div class="channel-icon-preview" id="channel-icon-preview">
                <span>📢</span>
            </div>
            
            <input type="text" class="modal-input" id="channel-icon-url-input" placeholder="URL iframe для иконки (например: https://example.com/icon.html)">
            
            <button class="modal-btn modal-btn-primary" id="add-channel-icon-btn" style="width: 100%; margin-bottom: 15px;">Добавить иконку</button>
            
            <label>Текущие иконки:</label>
            <div class="channel-icon-list" id="channel-icons-list">
                <div style="text-align: center; color: var(--text-light); padding: 10px;">Нет добавленных иконок</div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="cancel-channel-icons-btn">Закрыть</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно звонка -->
    <div class="call-modal" id="call-modal">
        <div class="call-container">
            <div class="call-header">
                <div class="call-avatar" id="call-avatar">?</div>
                <h2 class="call-name" id="call-name">Пользователь</h2>
                <p class="call-status" id="call-status">Вызов...</p>
            </div>
            
            <div class="call-videos" id="call-videos">
                <video class="call-video-remote" id="remote-video" autoplay playsinline></video>
                <video class="call-video-local" id="local-video" autoplay playsinline muted></video>
            </div>
            
            <div class="call-audio-only" id="call-audio-only" style="display: none;">
                <div class="call-audio-icon">📞</div>
                <p>Аудиозвонок</p>
            </div>
            
            <div class="call-controls">
                <button class="call-btn" id="call-mute-btn" title="Выключить микрофон">
                    <span id="call-mute-icon">🎤</span>
                </button>
                <button class="call-btn call-btn-end" id="call-end-btn" title="Завершить звонок">
                    <span>📞</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно входящего звонка -->
    <div class="call-modal" id="incoming-call-modal">
        <div class="call-container">
            <div class="call-header">
                <div class="call-avatar" id="incoming-call-avatar">?</div>
                <h2 class="call-name" id="incoming-call-name">Пользователь</h2>
                <p class="call-status">Входящий звонок...</p>
            </div>
            
            <div class="call-controls">
                <button class="call-btn call-btn-accept" id="call-accept-btn" title="Принять">
                    <span>📞</span>
                </button>
                <button class="call-btn call-btn-end" id="call-decline-btn" title="Отклонить">
                    <span>📞</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно просмотра профиля -->
    <div class="modal" id="profile-view-modal">
        <div class="modal-content">
            <h2 class="modal-title">Профиль пользователя</h2>
            
            <div class="user-profile-info">
                <div class="user-avatar" id="profile-avatar" style="width: 120px; height: 120px; font-size: 3.5rem; margin: 0 auto 15px; border: 4px solid var(--primary-color); border-radius: 50%; display: flex; align-items: center; justify-content: center;">?</div>
                <h3 id="profile-name" style="font-size: 1.8rem; margin: 10px 0; color: var(--primary-color);">Имя пользователя</h3>
                <p id="profile-username" style="font-size: 1.1rem; margin: 5px 0; color: var(--text-light);">@username</p>
                <p id="profile-status" style="font-size: 1rem; margin: 8px 0;">Статус</p>
            </div>
            
            <div class="user-gifts-section">
                <h3 style="margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid var(--primary-color); color: var(--primary-color);">Полученные подарки</h3>
                <div class="gifts-list" id="gifts-list" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                    <!-- Список подарков будет здесь -->
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="close-profile-view-btn">Закрыть</button>
            </div>
        </div>
    </div>
    
    <script>
        // Firebase конфигурация
        const firebaseConfig = {
            apiKey: "AIzaSyAhO3JsDI61pkpGla045EfEXq6h7EuGHoQ",
            authDomain: "ukraine-52ad4.firebaseapp.com",
            databaseURL: "https://ukraine-52ad4-default-rtdb.firebaseio.com",
            projectId: "ukraine-52ad4",
            storageBucket: "ukraine-52ad4.firebasestorage.app",
            messagingSenderId: "63107581219",
            appId: "1:63107581219:web:074b8e692a8a8b04737896",
            measurementId: "G-J4M8NV6TC9"
        };

        // Инициализация Firebase
        let database;
        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            console.log('Firebase инициализирован успешно');
        } catch (error) {
            console.error('Ошибка инициализации Firebase:', error);
        }

        // Элементы DOM
        const currentUserEl = document.getElementById('current-user');
        const userEmojiEl = document.getElementById('user-emoji');
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        const emptyState = document.getElementById('empty-state');
        const chatHeader = document.getElementById('chat-header');
        const chatAvatar = document.getElementById('chat-avatar');
        const chatUserName = document.getElementById('chat-user-name');
        const chatUserEmoji = document.getElementById('chat-user-emoji');
        const chatMessages = document.getElementById('chat-messages');
        const messageInputContainer = document.getElementById('message-input-container');
        const messageText = document.getElementById('message-text');
        const sendBtn = document.getElementById('send-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const notification = document.getElementById('notification');
        const menuBtn = document.getElementById('menu-btn');
        const backBtn = document.getElementById('back-btn');
        const closeChatBtn = document.getElementById('close-chat-btn');
        const sidebar = document.getElementById('sidebar');
        const mobileTitle = document.getElementById('mobile-title');
        const settingsModal = document.getElementById('settings-modal');
        const newUsernameInput = document.getElementById('new-username-input');
        const cancelSettingsBtn = document.getElementById('cancel-settings-btn');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const chatsTab = document.getElementById('chats-tab');
        const usersTab = document.getElementById('users-tab');
        const channelsTab = document.getElementById('channels-tab');
        const themeToggle = document.getElementById('theme-toggle');
        const notificationToggle = document.getElementById('notification-toggle');
        const notificationStatus = document.getElementById('notification-status');
        const testNotificationBtn = document.getElementById('test-notification-btn');
        const emojiOptions = document.getElementById('emoji-options');
        const editMessageModal = document.getElementById('edit-message-modal');
        const editMessageText = document.getElementById('edit-message-text');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const saveEditBtn = document.getElementById('save-edit-btn');
        const createGroupBtn = document.getElementById('create-group-menu-btn');
        const createGroupModal = document.getElementById('create-group-modal');
        const groupNameInput = document.getElementById('group-name-input');
        const participantsList = document.getElementById('participants-list');
        const cancelGroupBtn = document.getElementById('cancel-group-btn');
        const createGroupConfirmBtn = document.getElementById('create-group-confirm-btn');
        const blockUserBtn = document.getElementById('block-user-btn');
        const deleteChatBtn = document.getElementById('delete-chat-btn');
        const connectionStatus = document.getElementById('connection-status');
        const blockedList = document.getElementById('blocked-list');
        const groupSettingsBtn = document.getElementById('group-settings-btn');
        const groupSettingsModal = document.getElementById('group-settings-modal');
        const editGroupNameInput = document.getElementById('edit-group-name-input');
        const editParticipantsList = document.getElementById('edit-participants-list');
        const cancelGroupSettingsBtn = document.getElementById('cancel-group-settings-btn');
        const saveGroupSettingsBtn = document.getElementById('save-group-settings-btn');
        const leaveGroupBtn = document.getElementById('leave-group-btn');
        const createChannelBtn = document.getElementById('create-channel-menu-btn');
        const createChannelModal = document.getElementById('create-channel-modal');
        const channelNameInput = document.getElementById('channel-name-input');
        const channelDescriptionInput = document.getElementById('channel-description-input');
        const cancelChannelBtn = document.getElementById('cancel-channel-btn');
        const createChannelConfirmBtn = document.getElementById('create-channel-confirm-btn');
        const channelSettingsBtn = document.getElementById('channel-settings-btn');
        const channelSettingsModal = document.getElementById('channel-settings-modal');
        const editChannelNameInput = document.getElementById('edit-channel-name-input');
        const editChannelDescriptionInput = document.getElementById('edit-channel-description-input');
        const cancelChannelSettingsBtn = document.getElementById('cancel-channel-settings-btn');
        const saveChannelSettingsBtn = document.getElementById('save-channel-settings-btn');
        const unsubscribeChannelBtn = document.getElementById('unsubscribe-channel-btn');
        const settingsMenu = document.getElementById('settings-menu');
        const logoutMenuBtn = document.getElementById('logout-menu-btn');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        
        // Элементы для управления иконками каналов
        const channelIconsModal = document.getElementById('channel-icons-modal');
        const channelIconUrlInput = document.getElementById('channel-icon-url-input');
        const addChannelIconBtn = document.getElementById('add-channel-icon-btn');
        const cancelChannelIconsBtn = document.getElementById('cancel-channel-icons-btn');
        const channelIconsList = document.getElementById('channel-icons-list');
        const channelIconPreview = document.getElementById('channel-icon-preview');
        const manageChannelIconsBtn = document.getElementById('manage-channel-icons-btn');
        
        // Состояние приложения
        let currentUser = null;
        let currentChat = null;
        let currentChatType = null; // 'user', 'group', 'channel'
        let messageListeners = {};
        let activeTab = 'chats';
        let userEmoji = '😊';
        let editingMessageId = null;
        let isOnline = navigator.onLine;
        let blockedUsers = [];
        let groups = [];
        let currentGroup = null;
        let channels = [];
        let currentChannel = null;
        let subscribedChannels = [];
        let lastMessageTimestamp = 0;
        let backgroundCheckIntervals = [];
        let notifiedMessageIds = new Set();
        
        // Gift system variables
        let giftCount = 1000; // Total gifts available
        let sentGiftsToday = {}; // Track gifts sent today {username: timestamp}
        let userGifts = {}; // Track gifts received by user {username: [gifts]}
        
        // Функция показа уведомлений
        function showNotification(message) {
            if (!notification) {
                console.log('Notification:', message);
                return;
            }
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // Инициализация
        document.addEventListener('DOMContentLoaded', initApp);
        
        async function initApp() {
            setupEventListeners();
            setupNetworkStatus();
            
            // Регистрируем Service Worker для фоновых уведомлений
            registerServiceWorker();
            
            // Настраиваем автоматический запрос разрешения на уведомления
            setupAutoNotificationRequest();
            
            // Проверяем сохраненную тему
            if (localStorage.getItem('dark_theme') === 'true') {
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
            }
            
            // Инициализируем настройки уведомлений
            initializeNotificationSettings();
            
            // Проверяем, есть ли сохраненный пользователь
            const savedUser = localStorage.getItem('messenger_user');
            if (savedUser) {
                try {
                    const userData = JSON.parse(savedUser);
                    if (userData && userData.username && userData.password) {
                        // Автоматический вход
                        const userRef = database.ref('users/' + encodeURIComponent(userData.username));
                        const snapshot = await userRef.once('value');
                        
                        if (snapshot.exists()) {
                            const dbUserData = snapshot.val();
                            if (dbUserData.password === userData.password) {
                                currentUser = userData.username;
                                currentUserData = dbUserData;
                                userEmoji = dbUserData.emoji || '😊';
                                blockedUsers = dbUserData.blockedUsers || [];
                                subscribedChannels = dbUserData.subscribedChannels || [];
                                
                                currentUserEl.querySelector('span:last-child').textContent = dbUserData.name || userData.username;
                                userEmojiEl.textContent = userEmoji;
                                
                                await updateUserStatus(true);
                                loadRecentChats();
                                loadGroups();
                                loadChannels();
                                
                                startBackgroundChecks();
                                trackUserStatus();
                                subscribeToPushNotifications();
                                initCallListeners();
                            } else {
                                localStorage.removeItem('messenger_user');
                                requestUsername();
                            }
                        } else {
                            localStorage.removeItem('messenger_user');
                            requestUsername();
                        }
                    } else {
                        localStorage.removeItem('messenger_user');
                        requestUsername();
                    }
                } catch (e) {
                    localStorage.removeItem('messenger_user');
                    requestUsername();
                }
            } else {
                // Если пользователя нет, запрашиваем вход/регистрацию
                requestUsername();
            }
            
            // Адаптация для мобильных
            if (window.innerWidth <= 768) {
                mobileTitle.textContent = 'Twin';
            }
            
            // Оптимизация для Android
            optimizeForAndroid();
            
            // Initialize daily gift tracker
            initializeDailyGiftTracker();
        }
        
        // Функция запроса разрешения на уведомления
        function requestNotificationPermission() {
            if (!("Notification" in window)) {
                console.log("Браузер не поддерживает уведомления");
                return Promise.resolve("not_supported");
            }
            
            // Если уже разрешено - ничего не делаем
            if (Notification.permission === "granted") {
                return Promise.resolve("granted");
            }
            
            // Если запрещено - не запрашиваем
            if (Notification.permission === "denied") {
                return Promise.resolve("denied");
            }
            
            // Запрашиваем разрешение
            return Notification.requestPermission();
        }
        
        // Автоматический запрос разрешения на уведомления при первом взаимодействии
        function setupAutoNotificationRequest() {
            if (!("Notification" in window)) return;
            if (Notification.permission !== "default") return;
            
            const autoRequestPermission = () => {
                // Инициализируем аудио контекст при первом взаимодействии
                initAudioContext();
                
                // Проверяем, не запрашивали ли уже
                const alreadyRequested = sessionStorage.getItem('notification_requested');
                if (alreadyRequested) return;
                
                Notification.requestPermission().then(permission => {
                    sessionStorage.setItem('notification_requested', 'true');
                    if (permission === "granted") {
                        console.log("Разрешение на уведомления получено автоматически");
                        localStorage.setItem('notifications_enabled', 'true');
                        showNotification('Уведомления включены!');
                    }
                });
            };
            
            // Запрашиваем при первом клике или нажатии клавиши
            document.addEventListener('click', autoRequestPermission, { once: true });
            document.addEventListener('keypress', autoRequestPermission, { once: true });
            document.addEventListener('touchstart', autoRequestPermission, { once: true });
        }
        
        // Инициализация настроек уведомлений при загрузке
        function initializeNotificationSettings() {
            if (!("Notification" in window)) {
                localStorage.setItem('notifications_enabled', 'false');
                return;
            }
            
            // Если разрешение получено, но настройка еще не сохранена - включаем по умолчанию
            if (Notification.permission === "granted") {
                if (localStorage.getItem('notifications_enabled') === null) {
                    localStorage.setItem('notifications_enabled', 'true');
                }
            } else if (Notification.permission === "denied") {
                localStorage.setItem('notifications_enabled', 'false');
            }
        }
        
        // Регистрация Service Worker
        function registerServiceWorker() {
            // Service Worker не работает на file:// протоколе (локальные файлы)
            // И не может быть зарегистрирован из blob:// URL на HTTPS
            // Используем альтернативный метод уведомлений
            if ('serviceWorker' in navigator) {
                // Проверяем, что страница не открыта с file:// протокола
                if (window.location.protocol === 'file:') {
                    console.log('Service Worker не поддерживается при открытии файла локально (file://). Используйте локальный сервер (Live Server) или разместите на хостинге.');
                    return;
                }
                
                // Проверяем, что страница не открыта через blob:// протокол
                if (window.location.protocol === 'blob:') {
                    console.log('Service Worker не поддерживается при открытии через blob:// протокол.');
                    return;
                }
                
                // Service Worker не может быть зарегистрирован из blob URL при HTTPS
                // Пропускаем регистрацию, так как это одностраничное приложение
                // Уведомления будут работать через Firebase и Notification API напрямую
                console.log('Service Worker пропущен: встроенный SW не поддерживается на HTTPS. Используем стандартные уведомления.');
            }
        }
        
        // Подписка на push-уведомления через Firebase
        function subscribeToPushNotifications() {
            if (!currentUser) return;
            
            // Создаем слушатель для уведомлений в Firebase
            const notificationsRef = database.ref('users/' + encodeURIComponent(currentUser) + '/notifications');
            
            notificationsRef.on('child_added', (snapshot) => {
                const notification = snapshot.val();
                if (notification && !notification.read) {
                    // Показываем браузерное уведомление
                    showBrowserNotification(
                        getNotificationTitle(notification),
                        getNotificationBody(notification)
                    );
                    
                    // Помечаем уведомление как прочитанное
                    snapshot.ref.update({ read: true });
                }
            });
        }
        
        // Получение заголовка уведомления
        function getNotificationTitle(notification) {
            switch (notification.type) {
                case 'message':
                    return 'Новое сообщение';
                case 'group_message':
                    return `Сообщение в группе "${notification.chatName || 'Группа'}"`;
                case 'channel_message':
                    return `Сообщение в канале "${notification.chatName || 'Канал'}"`;
                case 'group_invite':
                    return 'Приглашение в группу';
                case 'group_remove':
                    return 'Группа';
                case 'new_subscriber':
                    return 'Новый подписчик';
                default:
                    return 'Twin Messenger';
            }
        }
        
        // Получение текста уведомления
        function getNotificationBody(notification) {
            switch (notification.type) {
                case 'message':
                case 'group_message':
                case 'channel_message':
                    return `${notification.from}: ${notification.text || 'Новое сообщение'}`;
                case 'group_invite':
                    return `${notification.from} добавил вас в группу "${notification.groupName}"`;
                case 'group_remove':
                    return `Вы удалены из группы "${notification.groupName}"`;
                case 'new_subscriber':
                    return `${notification.from} подписался на ваш канал "${notification.channelName}"`;
                default:
                    return notification.text || 'Новое уведомление';
            }
        }
        
        function optimizeForAndroid() {
            // Базовая оптимизация для мобильных устройств
            if ('ontouchstart' in window) {
                document.body.classList.add('touch-device');
            }
            
            // Предотвращение масштабирования при фокусе на поле ввода
            messageText.addEventListener('focus', function() {
                setTimeout(() => {
                    window.scrollTo(0, 0);
                }, 100);
            });
        }
        
        // Настройка свайп-жестов для мобильной навигации
        function setupSwipeGestures() {
            // Свайпы временно отключены для стабильности
            // Можно включить позже, если потребуется
            return;
        }
        
        function openProfileSettings() {
            document.getElementById('profile-username-input').value = currentUserData ? (currentUserData.name || '') : '';
            
            document.querySelectorAll('#profile-emoji-options .emoji-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.emoji === userEmoji) {
                    opt.classList.add('selected');
                }
            });
            
            document.getElementById('profile-settings-modal').classList.add('active');
            
            // Load user's gifts
            loadMyGifts();
            
            // Ensure the gifts section is visible initially (it will be hidden by loadMyGifts if no gifts)
            const giftsSection = document.querySelector('.user-gifts-section');
            if (giftsSection) {
                giftsSection.style.display = 'block';
            }
        }

        function closeProfileSettings() {
            document.getElementById('profile-settings-modal').classList.remove('active');
        }

        async function saveProfileSettings() {
            const newName = document.getElementById('profile-username-input').value.trim();
            
            if (!newName) {
                showNotification('Пожалуйста, введите имя');
                return;
            }
            
            try {
                await database.ref('users/' + encodeURIComponent(currentUser)).update({
                    name: newName,
                    emoji: userEmoji
                });
                
                if (currentUserData) {
                    currentUserData.name = newName;
                    currentUserData.emoji = userEmoji;
                }
                
                userEmojiEl.textContent = userEmoji;
                currentUserEl.querySelector('span:last-child').textContent = newName;
                showNotification('Настройки профиля сохранены');
                closeProfileSettings();
                
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        function setupEventListeners() {
            document.getElementById('profile-emoji-options').addEventListener('click', (e) => {
                if (e.target.classList.contains('emoji-option')) {
                    document.querySelectorAll('#profile-emoji-options .emoji-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    e.target.classList.add('selected');
                    userEmoji = e.target.dataset.emoji;
                }
            });
            
            searchInput.addEventListener('input', debounce(handleSearch, 300));
            
            sendBtn.addEventListener('click', sendMessage);
            
            messageText.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
                // Auto-resize textarea as user types
                setTimeout(() => {
                    autoResizeTextarea();
                }, 0);
            });
            
            messageText.addEventListener('input', () => {
                autoResizeTextarea();
            });
            
            messageText.addEventListener('focus', () => {
                setTimeout(() => {
                    scrollToBottom();
                }, 300);
            });
            
            logoutBtn.addEventListener('click', handleLogout);
            logoutMenuBtn.addEventListener('click', handleLogout);
            
            settingsBtn.addEventListener('click', toggleSettingsMenu);
            cancelSettingsBtn.addEventListener('click', closeSettings);
            saveSettingsBtn.addEventListener('click', saveSettings);
            
            document.getElementById('profile-settings-btn').addEventListener('click', openProfileSettings);
            document.getElementById('cancel-profile-settings-btn').addEventListener('click', closeProfileSettings);
            document.getElementById('save-profile-settings-btn').addEventListener('click', saveProfileSettings);
            
            createGroupBtn.addEventListener('click', openCreateGroup);
            cancelGroupBtn.addEventListener('click', closeCreateGroup);
            createGroupConfirmBtn.addEventListener('click', createGroup);
            
            createChannelBtn.addEventListener('click', openCreateChannel);
            cancelChannelBtn.addEventListener('click', closeCreateChannel);
            createChannelConfirmBtn.addEventListener('click', createChannel);
            
            groupSettingsBtn.addEventListener('click', openGroupSettings);
            cancelGroupSettingsBtn.addEventListener('click', closeGroupSettings);
            saveGroupSettingsBtn.addEventListener('click', saveGroupSettings);
            leaveGroupBtn.addEventListener('click', leaveGroup);
            
            channelSettingsBtn.addEventListener('click', openChannelSettings);
            cancelChannelSettingsBtn.addEventListener('click', closeChannelSettings);
            saveChannelSettingsBtn.addEventListener('click', saveChannelSettings);
            unsubscribeChannelBtn.addEventListener('click', unsubscribeChannel);
            
            // Event listeners for channel icon management
            manageChannelIconsBtn.addEventListener('click', openChannelIconsModal);
            cancelChannelIconsBtn.addEventListener('click', closeChannelIconsModal);
            addChannelIconBtn.addEventListener('click', addChannelIcon);
            
            // Preview icon on input change
            channelIconUrlInput.addEventListener('input', updateChannelIconPreview);
            
            themeToggle.addEventListener('change', toggleTheme);
            notificationToggle.addEventListener('change', toggleNotifications);
            testNotificationBtn.addEventListener('click', testNotification);
            
            emojiOptions.addEventListener('click', (e) => {
                if (e.target.classList.contains('emoji-option')) {
                    document.querySelectorAll('.emoji-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    e.target.classList.add('selected');
                    userEmoji = e.target.dataset.emoji;
                }
            });
            
            cancelEditBtn.addEventListener('click', closeEditMessage);
            saveEditBtn.addEventListener('click', saveEditedMessage);
            
            menuBtn.addEventListener('click', toggleSidebar);
            backBtn.addEventListener('click', closeChat);
            closeChatBtn.addEventListener('click', closeChat);
            
            // Close sidebar when clicking overlay
            sidebarOverlay.addEventListener('click', closeSidebar);
            
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 768 && !sidebar.contains(e.target) && 
                    e.target !== menuBtn && !menuBtn.contains(e.target)) {
                    closeSidebar();
                }
                
                if (!settingsMenu.contains(e.target) && e.target !== settingsBtn && !settingsBtn.contains(e.target)) {
                    settingsMenu.classList.remove('active');
                }
            });
            
            window.addEventListener('resize', handleResize);
            
            chatsTab.addEventListener('click', () => switchTab('chats'));
            usersTab.addEventListener('click', () => switchTab('users'));
            channelsTab.addEventListener('click', () => switchTab('channels'));
            
            blockUserBtn.addEventListener('click', toggleBlockUser);
            deleteChatBtn.addEventListener('click', deleteChat);
            
            // Gift and Profile button event listeners
            document.getElementById('view-profile-btn').addEventListener('click', () => {
                if (currentChat && currentChatType === 'user') {
                    viewUserProfile(currentChat);
                }
            });
            
            document.getElementById('send-gift-btn').addEventListener('click', () => {
                if (currentChat && currentChatType === 'user') {
                    openGiftMarketplace();
                }
            });
            
            document.getElementById('close-profile-view-btn').addEventListener('click', () => {
                document.getElementById('profile-view-modal').classList.remove('active');
            });
            
            // Toggle between post interface and chat interface
            const createPostBtn = document.getElementById('create-post-btn');
            if (createPostBtn) {
                createPostBtn.addEventListener('click', function() {
                    // Hide sidebar on mobile
                    document.getElementById('sidebar').style.transform = 'translateX(-100%)';
                    document.getElementById('sidebar-overlay').classList.remove('active');
                    document.getElementById('mobile-menu-btn').style.display = 'flex';
                    
                    // Show post interface, hide chat interface
                    document.getElementById('main-content').style.display = 'block';
                    document.querySelector('.chat-area').style.display = 'none';
                    
                    // Update mobile header
                    document.getElementById('mobile-title').textContent = 'Create Post';
                    
                    // Update back button functionality
                    const mobileBackBtn = document.getElementById('mobile-back-btn');
                    if (mobileBackBtn) {
                        mobileBackBtn.onclick = function() {
                            document.getElementById('main-content').style.display = 'none';
                            document.querySelector('.chat-area').style.display = 'flex';
                            document.getElementById('mobile-title').textContent = 'Twin';
                        };
                    }
                });
            }
            
            // Handle post publishing
            const publishPostBtn = document.getElementById('publish-post-btn');
            if (publishPostBtn) {
                publishPostBtn.addEventListener('click', function() {
                    const postTextarea = document.querySelector('.post-field-textarea');
                    const postContent = postTextarea.value.trim();
                    
                    if (postContent) {
                        // Here you would typically send the post to your backend
                        console.log('Publishing post:', postContent);
                        
                        // Show success notification
                        showNotification('Post published successfully!');
                        
                        // Clear the post field
                        postTextarea.value = '';
                        postTextarea.dispatchEvent(new Event('input'));
                        postTextarea.style.height = 'auto';
                        
                        // Optionally redirect back to chat interface
                        setTimeout(function() {
                            document.getElementById('main-content').style.display = 'none';
                            document.querySelector('.chat-area').style.display = 'flex';
                            document.getElementById('mobile-title').textContent = 'Twin';
                        }, 1500);
                    } else {
                        showNotification('Please write something before publishing.');
                    }
                });
            }
            
            window.addEventListener('online', () => {
                isOnline = true;
                updateConnectionStatus();
                showNotification('Вы в сети');
            });
            
            window.addEventListener('offline', () => {
                isOnline = false;
                updateConnectionStatus();
                showNotification('Вы не в сети');
            });
        }
        
        function toggleSettingsMenu() {
            settingsMenu.classList.toggle('active');
            updateNotificationToggleState();
        }
        
        function updateNotificationToggleState() {
            if (!("Notification" in window)) {
                notificationToggle.disabled = true;
                notificationStatus.style.display = 'block';
                notificationStatus.textContent = 'Ваш браузер не поддерживает уведомления';
                testNotificationBtn.style.display = 'none';
                return;
            }
            
            // Проверяем сохраненные настройки
            const notificationsEnabled = localStorage.getItem('notifications_enabled') === 'true';
            
            if (Notification.permission === "granted") {
                notificationToggle.checked = notificationsEnabled;
                notificationToggle.disabled = false;
                notificationStatus.style.display = 'none';
                testNotificationBtn.style.display = notificationsEnabled ? 'block' : 'none';
            } else if (Notification.permission === "denied") {
                notificationToggle.checked = false;
                notificationToggle.disabled = true;
                notificationStatus.style.display = 'block';
                notificationStatus.textContent = 'Уведомления заблокированы в настройках браузера. Чтобы включить, измените настройки сайта в браузере.';
                testNotificationBtn.style.display = 'none';
                localStorage.setItem('notifications_enabled', 'false');
            } else {
                notificationToggle.checked = false;
                notificationToggle.disabled = false;
                notificationStatus.style.display = 'none';
                testNotificationBtn.style.display = 'none';
            }
        }
        
        function testNotification() {
            if (!("Notification" in window)) {
                showNotification('Ваш браузер не поддерживает уведомления');
                return;
            }
            
            if (Notification.permission !== "granted") {
                // Запрашиваем разрешение если еще не получено
                Notification.requestPermission().then(permission => {
                    if (permission === "granted") {
                        localStorage.setItem('notifications_enabled', 'true');
                        showBrowserNotification('Twin Messenger', 'Это тестовое уведомление! Уведомления работают корректно.');
                        showNotification('Тестовое уведомление отправлено');
                        updateNotificationToggleState();
                    } else {
                        showNotification('Разрешение на уведомления не получено');
                    }
                });
            } else {
                showBrowserNotification('Twin Messenger', 'Это тестовое уведомление! Уведомления работают корректно.');
                showNotification('Тестовое уведомление отправлено');
            }
        }
        
        function toggleNotifications() {
            if (notificationToggle.checked) {
                // Запрашиваем разрешение
                if ("Notification" in window) {
                    if (Notification.permission === "default") {
                        Notification.requestPermission().then(permission => {
                            if (permission === "granted") {
                                console.log("Разрешение на уведомления получено");
                                localStorage.setItem('notifications_enabled', 'true');
                                showNotification('Уведомления включены!');
                            } else {
                                notificationToggle.checked = false;
                                localStorage.setItem('notifications_enabled', 'false');
                                updateNotificationToggleState();
                            }
                        });
                    } else if (Notification.permission === "granted") {
                        localStorage.setItem('notifications_enabled', 'true');
                        showNotification('Уведомления включены!');
                    } else if (Notification.permission === "denied") {
                        notificationToggle.checked = false;
                        localStorage.setItem('notifications_enabled', 'false');
                        updateNotificationToggleState();
                    }
                }
            } else {
                localStorage.setItem('notifications_enabled', 'false');
                showNotification('Уведомления отключены');
            }
            updateNotificationToggleState();
        }
        
        function setupNetworkStatus() {
            updateConnectionStatus();
        }
        
        function updateConnectionStatus() {
            if (isOnline) {
                connectionStatus.classList.remove('offline');
                document.querySelector('.user-profile p').innerHTML = 'Онлайн <span class="connection-status" id="connection-status"></span>';
            } else {
                connectionStatus.classList.add('offline');
                document.querySelector('.user-profile p').innerHTML = 'Офлайн <span class="connection-status offline" id="connection-status"></span>';
            }
        }
        
        function startBackgroundChecks() {
            // Clear any existing intervals first to prevent duplicates
            backgroundCheckIntervals.forEach(intervalId => clearInterval(intervalId));
            backgroundCheckIntervals = [];
            
            // Clear notified message IDs when restarting checks
            notifiedMessageIds.clear();
            
            backgroundCheckIntervals.push(setInterval(checkForNewMessages, 5000));
            backgroundCheckIntervals.push(setInterval(checkForGroupInvites, 10000));
            backgroundCheckIntervals.push(setInterval(checkForChannelUpdates, 15000));
        }
        
        async function checkForNewMessages() {
            if (!currentUser || !isOnline) {
                console.log('[CheckMessages] Skipping: no user or offline');
                return;
            }
            
            try {
                console.log('[CheckMessages] Checking for new messages...');
                const snapshot = await database.ref('messages').once('value');
                const allChats = snapshot.val();
                if (!allChats) {
                    console.log('[CheckMessages] No chats found');
                    return;
                }
                
                const now = Date.now();
                // Initialize lastMessageTimestamp on first run to current time to avoid showing old messages
                if (lastMessageTimestamp === 0) {
                    lastMessageTimestamp = now - 5000; // Allow messages from last 5 seconds
                    console.log('[CheckMessages] Initialized timestamp:', lastMessageTimestamp);
                }
                
                Object.keys(allChats).forEach(chatId => {
                    if (chatId.includes(currentUser) || (chatId.startsWith('group_') && groups.some(g => g.id === chatId)) || 
                        (chatId.startsWith('channel_') && subscribedChannels.includes(chatId))) {
                        const messages = allChats[chatId];
                        const messagesArray = Object.keys(messages).map(key => ({
                            id: key,
                            ...messages[key]
                        }));
                        
                        const latestMessage = messagesArray
                            .filter(msg => msg.text && msg.sender && msg.timestamp)
                            .sort((a, b) => b.timestamp - a.timestamp)[0];
                        
                        // Проверяем, есть ли новое сообщение
                        if (!latestMessage) return;
                        
                        // Check if we've already notified about this specific message
                        const messageId = latestMessage.id;
                        const isNewMessage = latestMessage.timestamp > lastMessageTimestamp;
                        const isNotFromMe = latestMessage.sender !== currentUser;
                        const notAlreadyNotified = !notifiedMessageIds.has(messageId);
                        
                        if (isNewMessage && isNotFromMe && notAlreadyNotified) {
                            console.log('[CheckMessages] New message found:', latestMessage.text, 'from:', latestMessage.sender);
                            
                            // Mark this message as notified
                            notifiedMessageIds.add(messageId);
                            
                            // Limit the size of the set to prevent memory leaks
                            if (notifiedMessageIds.size > 100) {
                                const firstId = notifiedMessageIds.values().next().value;
                                notifiedMessageIds.delete(firstId);
                            }
                            
                            let senderName = latestMessage.sender;
                            let chatName = '';
                            let notificationType = 'message';
                            
                            if (chatId.startsWith('group_')) {
                                const group = groups.find(g => g.id === chatId);
                                if (group) {
                                    chatName = group.name;
                                    senderName = `${group.name}`;
                                    notificationType = 'group_message';
                                }
                            } else if (chatId.startsWith('channel_')) {
                                const channel = channels.find(c => c.id === chatId);
                                if (channel) {
                                    chatName = channel.name;
                                    senderName = `${channel.name}`;
                                    notificationType = 'channel_message';
                                }
                            } else {
                                // Личный чат
                                chatName = latestMessage.sender;
                            }
                            
                            // Показываем уведомления ВСЕГДА, если:
                            // 1. Вкладка не активна (document.hidden) ИЛИ
                            // 2. Чат не открыт (currentChat !== chatId)
                            const shouldNotify = document.hidden || currentChat !== chatId;
                            console.log('[CheckMessages] Should notify:', shouldNotify, 'hidden:', document.hidden, 'currentChat:', currentChat, 'chatId:', chatId);
                            
                            if (shouldNotify) {
                                // Show browser notification (system level)
                                showBrowserNotification(
                                    `Новое сообщение от ${chatName}`,
                                    latestMessage.text
                                );
                                
                                // Show Telegram-style toast notification (in-app)
                                let toastType = 'message';
                                let toastTitle = chatName;
                                let toastAvatar = null;
                                
                                if (chatId.startsWith('group_')) {
                                    toastType = 'group';
                                    toastAvatar = '👥';
                                } else if (chatId.startsWith('channel_')) {
                                    toastType = 'channel';
                                    toastAvatar = '📢';
                                } else {
                                    // Personal chat - get first letter of sender name
                                    toastAvatar = chatName.charAt(0).toUpperCase();
                                }
                                
                                showToastNotification({
                                    title: toastTitle,
                                    message: latestMessage.text,
                                    type: toastType,
                                    chatId: chatId,
                                    avatar: toastAvatar,
                                    duration: 6000
                                });
                            }
                            
                            // Создаем уведомление в Firebase для гарантированной доставки
                            createFirebaseNotification(latestMessage, chatName, notificationType);
                            
                            // Обновляем таймстамп
                            lastMessageTimestamp = latestMessage.timestamp;
                        }
                    }
                });
            } catch (error) {
                console.error('[CheckMessages] Error:', error);
            }
        }

// Создание уведомления в Firebase для гарантированной доставки
async function createFirebaseNotification(message, chatName, type) {
    if (!currentUser) return;
    
    try {
        const notificationsRef = database.ref('users/' + encodeURIComponent(currentUser) + '/notifications');
        await notificationsRef.push({
            type: type,
            from: message.sender,
            chatName: chatName,
            text: message.text,
            timestamp: Date.now(),
            read: false
        });
    } catch (error) {
        console.error('Ошибка создания уведомления в Firebase:', error);
    }
}
        
        async function checkForGroupInvites() {
            if (!currentUser || !isOnline) return;
            
            try {
                const snapshot = await database.ref('groups').once('value');
                const allGroups = snapshot.val();
                if (!allGroups) return;
                
                Object.keys(allGroups).forEach(groupId => {
                    const group = allGroups[groupId];
                    
                    // Notify if added to new group and (tab hidden OR not currently viewing that group)
                    const shouldNotify = document.hidden || currentChat !== groupId;
                    
                    if (group.participants && group.participants.includes(currentUser) && 
                        !groups.some(g => g.id === groupId) && shouldNotify) {
                        
                        showBrowserNotification('Twin Messenger', `Вас добавили в группу "${group.name}"`);
                        
                        // Show toast notification for group invite
                        showToastNotification({
                            title: 'Новая группа',
                            message: `Вас добавили в группу "${group.name}"`,
                            type: 'group',
                            chatId: groupId,
                            avatar: '👥',
                            duration: 5000
                        });
                        
                        loadGroups();
                    }
                });
            } catch (error) {
                console.error('Ошибка при проверке приглашений в группы:', error);
            }
        }
        
        async function checkForChannelUpdates() {
            if (!currentUser || !isOnline) return;
            
            try {
                const snapshot = await database.ref('channels').once('value');
                const allChannels = snapshot.val();
                if (!allChannels) return;
                
                Object.keys(allChannels).forEach(channelId => {
                    const channel = allChannels[channelId];
                    
                    if (subscribedChannels.includes(channelId) && channel.messages) {
                        const messages = Object.keys(channel.messages).map(key => ({
                            id: key,
                            ...channel.messages[key]
                        }));
                        
                        const latestMessage = messages
                            .filter(msg => msg.text && msg.sender && msg.timestamp)
                            .sort((a, b) => b.timestamp - a.timestamp)[0];
                        
                        if (!latestMessage) return;
                        
                        const messageId = latestMessage.id;
                        const isNewMessage = latestMessage.timestamp > lastMessageTimestamp;
                        const isNotFromMe = latestMessage.sender !== currentUser;
                        const notAlreadyNotified = !notifiedMessageIds.has(messageId);
                        // Notify if tab hidden OR different channel is open
                        const shouldNotify = document.hidden || currentChat !== channelId;
                        
                        if (isNewMessage && isNotFromMe && notAlreadyNotified && shouldNotify) {
                            
                            // Mark this message as notified
                            notifiedMessageIds.add(messageId);
                            
                            // Limit the size of the set to prevent memory leaks
                            if (notifiedMessageIds.size > 100) {
                                const firstId = notifiedMessageIds.values().next().value;
                                notifiedMessageIds.delete(firstId);
                            }
                            
                            showBrowserNotification(
                                `Новое сообщение в канале "${channel.name}"`,
                                latestMessage.text
                            );
                            
                            // Show toast notification for channel message
                            showToastNotification({
                                title: channel.name,
                                message: latestMessage.text,
                                type: 'channel',
                                chatId: channelId,
                                avatar: '📢',
                                duration: 6000
                            });
                            
                            lastMessageTimestamp = latestMessage.timestamp;
                        }
                    }
                });
            } catch (error) {
                console.error('Ошибка при проверке обновлений каналов:', error);
            }
        }
        
        function truncate(text, length) {
            return text.length > length ? text.substring(0, length) + '...' : text;
        }
        
        function toggleSidebar() {
            sidebar.classList.toggle('active');
            sidebarOverlay.classList.toggle('active');
        }
        
        function openSidebar() {
            sidebar.classList.add('active');
            sidebarOverlay.classList.add('active');
        }
        
        function closeSidebar() {
            sidebar.classList.remove('active');
            sidebarOverlay.classList.remove('active');
        }
        
        function handleResize() {
            if (window.innerWidth > 768) {
                sidebar.classList.remove('active');
            }
            
            if (window.innerWidth <= 768 && currentChat) {
                adjustMessageInput();
                scrollToBottom();
            }
        }
        
        function adjustMessageInput() {
            if (window.innerWidth <= 768 && currentChat) {
                const headerHeight = document.querySelector('.chat-header').offsetHeight;
                const inputHeight = document.querySelector('.message-input').offsetHeight;
                const windowHeight = window.innerHeight;
                
                chatMessages.style.height = `${windowHeight - headerHeight - inputHeight}px`;
                chatMessages.style.overflowY = 'auto';
            }
        }
        
        function autoResizeTextarea() {
            const textarea = messageText;
            if (!textarea) return;
            
            // Reset height to auto to calculate the correct scrollHeight
            textarea.style.height = 'auto';
            
            // Calculate the height needed for the content
            const scrollHeight = textarea.scrollHeight;
            
            // Set a maximum height to prevent the textarea from taking too much space
            const maxHeight = window.innerWidth <= 768 ? 150 : 200; // Lower max on mobile
            
            // Apply the calculated height with a maximum limit
            textarea.style.height = Math.min(scrollHeight, maxHeight) + 'px';
            
            // Adjust the chat messages area if needed
            if (currentChat) {
                adjustMessageInput();
            }
        }
        
        // Also listen for window resize events to adjust the textarea
        window.addEventListener('resize', () => {
            setTimeout(() => {
                autoResizeTextarea();
            }, 100);
        });
        
        function switchTab(tab) {
            activeTab = tab;
            
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            
            if (tab === 'chats') {
                chatsTab.classList.add('active');
                loadRecentChats();
            } else if (tab === 'users') {
                usersTab.classList.add('active');
                loadUsers();
            } else if (tab === 'channels') {
                channelsTab.classList.add('active');
                loadChannels();
            }
        }
        
        function toggleTheme() {
            if (themeToggle.checked) {
                document.body.classList.add('dark-theme');
                localStorage.setItem('dark_theme', 'true');
            } else {
                document.body.classList.remove('dark-theme');
                localStorage.setItem('dark_theme', 'false');
            }
        }
        
        async function openSettings() {
            newUsernameInput.value = currentUser || '';
            
            document.querySelectorAll('.emoji-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.emoji === userEmoji) {
                    opt.classList.add('selected');
                }
            });
            
            await loadBlockedUsers();
            displayBlockedUsers();
            
            settingsModal.classList.add('active');
            settingsMenu.classList.remove('active');
        }
        
        function closeSettings() {
            settingsModal.classList.remove('active');
        }
        
        async function saveSettings() {
            const newUsername = newUsernameInput.value.trim();
            
            if (!newUsername) {
                showNotification('Пожалуйста, введите новый никнейм');
                return;
            }
            
            if (newUsername === currentUser && userEmoji === userEmojiEl.textContent) {
                showNotification('Изменений нет');
                closeSettings();
                return;
            }
            
            try {
                if (newUsername !== currentUser) {
                    const userRef = database.ref('users/' + encodeURIComponent(newUsername));
                    const snapshot = await userRef.once('value');
                    
                    if (snapshot.exists()) {
                        showNotification('Этот никнейм уже занят');
                        return;
                    }
                    
                    await database.ref('users/' + encodeURIComponent(currentUser)).remove();
                    await database.ref('users/' + encodeURIComponent(newUsername)).set({
                        nickname: newUsername,
                        emoji: userEmoji,
                        online: true,
                        lastSeen: Date.now(),
                        blockedUsers: blockedUsers,
                        subscribedChannels: subscribedChannels
                    });
                    
                    localStorage.setItem('messenger_user', newUsername);
                    currentUser = newUsername;
                    currentUserEl.querySelector('span:last-child').textContent = newUsername;
                } else {
                    await database.ref('users/' + encodeURIComponent(currentUser)).update({
                        emoji: userEmoji,
                        blockedUsers: blockedUsers,
                        subscribedChannels: subscribedChannels
                    });
                }
                
                userEmojiEl.textContent = userEmoji;
                
                // Update post field avatar as well
                const postUserAvatar = document.getElementById('post-user-avatar');
                if (postUserAvatar) {
                    postUserAvatar.textContent = userEmoji.charAt(0).toUpperCase();
                }
                
                showNotification('Настройки сохранены');
                closeSettings();
                
                if (activeTab === 'chats') {
                    loadRecentChats();
                } else if (activeTab === 'users') {
                    loadUsers();
                } else if (activeTab === 'channels') {
                    loadChannels();
                }
                
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function loadUserData() {
            try {
                const snapshot = await database.ref('users/' + encodeURIComponent(currentUser)).once('value');
                const userData = snapshot.val();
                if (userData) {
                    currentUserData = userData;
                    if (userData.emoji) {
                        userEmoji = userData.emoji;
                        userEmojiEl.textContent = userEmoji;
                    }
                    if (userData.blockedUsers) {
                        blockedUsers = userData.blockedUsers;
                    }
                    if (userData.subscribedChannels) {
                        subscribedChannels = userData.subscribedChannels;
                    }
                }
            } catch (error) {
                console.error('Ошибка загрузки данных пользователя:', error);
            }
        }
        
        async function addUserToFirebase(username, emoji) {
            // Эта функция больше не используется напрямую, 
            // регистрация теперь происходит через requestUsername
            try {
                await database.ref('users/' + encodeURIComponent(username)).set({
                    username: username,
                    name: username,
                    emoji: emoji,
                    online: true,
                    lastSeen: Date.now(),
                    blockedUsers: [],
                    subscribedChannels: [],
                    recentChats: []
                });
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function updateUserStatus(online) {
    if (!currentUser) return;
    
    try {
        await database.ref('users/' + encodeURIComponent(currentUser)).update({
            online: online,
            lastSeen: Date.now()
        });
        
        // Уведомление о смене статуса
        if (online) {
            showNotification('🟢 Вы в сети');
        } else {
            showNotification('🔴 Вы не в сети');
        }
    } catch (error) {
        console.error('Ошибка обновления статуса:', error);
    }
}
        
        async function loadRecentChats() {
            try {
                searchResults.innerHTML = '<div style="text-align: center; padding: 10px; color: var(--text-light);">Загрузка чатов...</div>';
                
                const snapshot = await database.ref('messages').once('value');
                const allChats = snapshot.val();
                const recentChats = [];
                const addedUsernames = new Set();
                
                // Сначала добавляем пользователей из recentChats (сохраненных контактов)
                if (currentUserData && currentUserData.recentChats) {
                    for (const chat of currentUserData.recentChats) {
                        if (chat.username && !addedUsernames.has(chat.username)) {
                            addedUsernames.add(chat.username);
                            
                            // Получаем актуальные данные пользователя
                            const userSnapshot = await database.ref('users/' + encodeURIComponent(chat.username)).once('value');
                            const userData = userSnapshot.val();
                            
                            // Проверяем, есть ли сообщения с этим пользователем
                            const chatId = getChatId(currentUser, chat.username);
                            let lastMessageText = 'Нет сообщений';
                            let lastTimestamp = chat.addedAt || Date.now();
                            let lastSender = null;
                            
                            if (allChats && allChats[chatId]) {
                                const messages = allChats[chatId];
                                const messagesArray = Object.keys(messages).map(key => ({
                                    id: key,
                                    ...messages[key]
                                }));
                                
                                const lastMessage = messagesArray
                                    .filter(msg => msg.text && msg.sender && msg.timestamp)
                                    .sort((a, b) => b.timestamp - a.timestamp)[0];
                                
                                if (lastMessage) {
                                    lastMessageText = lastMessage.text;
                                    lastTimestamp = lastMessage.timestamp;
                                    lastSender = lastMessage.sender;
                                }
                            }
                            
                            recentChats.push({
                                id: chatId,
                                user: chat.username,
                                name: userData ? userData.name : chat.name,
                                emoji: userData ? userData.emoji : (chat.emoji || '😊'),
                                lastMessage: lastMessageText,
                                timestamp: lastTimestamp,
                                sender: lastSender,
                                type: 'user'
                            });
                        }
                    }
                }
                
                // Затем добавляем чаты с сообщениями (которых еще нет в списке)
                if (allChats) {
                    Object.keys(allChats).forEach(chatId => {
                        if (chatId.includes(currentUser) && !chatId.startsWith('group_') && !chatId.startsWith('channel_')) {
                            const messages = allChats[chatId];
                            
                            const messagesArray = Object.keys(messages).map(key => ({
                                id: key,
                                ...messages[key]
                            }));
                            
                            const lastMessage = messagesArray
                                .filter(msg => msg.text && msg.sender && msg.timestamp)
                                .sort((a, b) => b.timestamp - a.timestamp)[0];
                            
                            if (lastMessage) {
                                const otherUser = chatId.replace(currentUser, '').replace('_', '');
                                
                                if (!addedUsernames.has(otherUser)) {
                                    addedUsernames.add(otherUser);
                                    recentChats.push({
                                        id: chatId,
                                        user: otherUser,
                                        lastMessage: lastMessage.text,
                                        timestamp: lastMessage.timestamp,
                                        sender: lastMessage.sender,
                                        type: 'user'
                                    });
                                }
                            }
                        }
                    });
                }
                
                for (const group of groups) {
                    const groupId = group.id;
                    const groupMessages = allChats && allChats[groupId];
                    
                    if (groupMessages) {
                        const messagesArray = Object.keys(groupMessages).map(key => ({
                            id: key,
                            ...groupMessages[key]
                        }));
                        
                        const lastMessage = messagesArray
                            .filter(msg => msg.text && msg.sender && msg.timestamp)
                            .sort((a, b) => b.timestamp - a.timestamp)[0];
                        
                        if (lastMessage) {
                            recentChats.push({
                                id: groupId,
                                name: group.name,
                                lastMessage: lastMessage.text,
                                timestamp: lastMessage.timestamp,
                                sender: lastMessage.sender,
                                type: 'group'
                            });
                        }
                    } else {
                        recentChats.push({
                            id: groupId,
                            name: group.name,
                            lastMessage: 'Нет сообщений',
                            timestamp: group.createdAt,
                            sender: null,
                            type: 'group'
                        });
                    }
                }
                
                for (const channel of channels) {
                    const channelId = channel.id;
                    
                    // Only show subscribed channels in Chats tab
                    if (!subscribedChannels.includes(channelId)) {
                        continue;
                    }
                    
                    const channelMessages = allChats && allChats[channelId];
                    
                    if (channelMessages) {
                        const messagesArray = Object.keys(channelMessages).map(key => ({
                            id: key,
                            ...channelMessages[key]
                        }));
                        
                        const lastMessage = messagesArray
                            .filter(msg => msg.text && msg.sender && msg.timestamp)
                            .sort((a, b) => b.timestamp - a.timestamp)[0];
                        
                        if (lastMessage) {
                            recentChats.push({
                                id: channelId,
                                name: channel.name,
                                lastMessage: lastMessage.text,
                                timestamp: lastMessage.timestamp,
                                sender: lastMessage.sender,
                                type: 'channel'
                            });
                        }
                    } else {
                        recentChats.push({
                            id: channelId,
                            name: channel.name,
                            lastMessage: 'Нет сообщений',
                            timestamp: channel.createdAt,
                            sender: null,
                            type: 'channel'
                        });
                    }
                }
                
                recentChats.sort((a, b) => b.timestamp - a.timestamp);
                
                displayRecentChats(recentChats);
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
                searchResults.innerHTML = '<div class="user-item">Ошибка загрузки чатов</div>';
            }
        }
        
        async function displayRecentChats(chats) {
            searchResults.innerHTML = '';
            
            if (chats.length === 0) {
                searchResults.innerHTML = '<div class="user-item" style="text-align: center; color: var(--text-light);">У вас пока нет чатов.<br>Найдите пользователя через поиск во вкладке "Пользователи"</div>';
                return;
            }
            
            // Получаем данные пользователей для чатов без данных
            const usersPromises = chats
                .filter(chat => chat.type === 'user' && !chat.name)
                .map(async chat => {
                    const snapshot = await database.ref('users/' + encodeURIComponent(chat.user)).once('value');
                    const userData = snapshot.val();
                    return {
                        ...chat,
                        userData: userData || { name: chat.user, username: chat.user, online: false, emoji: '😊' }
                    };
                });
            
            const chatsWithUserData = await Promise.all(usersPromises);
            
            // Объединяем чаты с данными
            const allChats = chats.map(chat => {
                if (chat.type === 'user' && !chat.name) {
                    const chatWithData = chatsWithUserData.find(c => c.id === chat.id);
                    return chatWithData || chat;
                }
                return chat;
            });
            
            allChats.forEach(chat => {
                const userItem = document.createElement('div');
                userItem.className = 'user-item';
                
                const messageDate = new Date(chat.timestamp);
                const timeString = messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                let lastMessageText = chat.lastMessage;
                if (chat.type === 'user') {
                    if (chat.sender === currentUser) {
                        lastMessageText = `Вы: ${lastMessageText}`;
                    }
                } else {
                    if (chat.sender) {
                        lastMessageText = `${chat.sender}: ${lastMessageText}`;
                    }
                }
                
                let avatar, name, emoji, username;
                if (chat.type === 'user') {
                    const displayName = chat.name || (chat.userData ? chat.userData.name : chat.user) || 'Unknown';
                    const displayEmoji = chat.emoji || (chat.userData ? chat.userData.emoji : '😊');
                    const displayUsername = chat.user || (chat.userData ? chat.userData.username : '');
                    avatar = displayName.charAt(0).toUpperCase();
                    name = displayName;
                    emoji = displayEmoji;
                    username = displayUsername;
                } else if (chat.type === 'group') {
                    avatar = '👥';
                    name = chat.name;
                    emoji = '👥';
                } else { // channel
                    const channel = channels.find(c => c.id === chat.id);
                    if (channel && channel.icons && channel.icons.length > 0) {
                        avatar = getChannelIconHtml(channel);
                    } else {
                        avatar = '📢';
                    }
                    name = chat.name;
                    emoji = '📢';
                }
                
                userItem.innerHTML = `
                    <div class="user-avatar">${avatar}</div>
                    <div class="user-info">
                        <h3>
                            <span class="user-emoji-small">${emoji}</span>
                            <span>${escapeHtml(name)}</span>
                        </h3>
                        ${chat.type === 'user' && username ? `<p style="font-size: 0.75rem; color: var(--text-light);">@${username}</p>` : ''}
                        <div class="chat-preview">
                            <div class="last-message">${escapeHtml(lastMessageText)}</div>
                            <div class="last-time">${formatLastSeen(chat.timestamp)}</div>
                        </div>
                    </div>
                    <div class="chat-actions">
                        <button class="chat-action-btn delete-chat-btn" data-chat-id="${chat.id}" data-chat-type="${chat.type}" title="Удалить чат">🗑️</button>
                    </div>
                `;
                
                userItem.addEventListener('click', (e) => {
                    if (e.target.classList.contains('delete-chat-btn')) {
                        return;
                    }
                    
                    if (chat.type === 'user') {
                        const displayName = chat.name || (chat.userData ? chat.userData.name : chat.user);
                        const displayEmoji = chat.emoji || (chat.userData ? chat.userData.emoji : '😊');
                        openChat(chat.user, displayEmoji, displayName);
                    } else if (chat.type === 'group') {
                        openGroupChat(chat.id, chat.name);
                    } else if (chat.type === 'channel') {
                        openChannelChat(chat.id, chat.name);
                    }
                });
                
                const deleteBtn = userItem.querySelector('.delete-chat-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    let confirmMessage = '';
                    if (chat.type === 'group') {
                        const group = groups.find(g => g.id === chat.id);
                        if (group && group.admin === currentUser) {
                            confirmMessage = 'Вы уверены, что хотите удалить эту группу? Это действие необратимо.';
                        } else {
                            confirmMessage = 'Вы уверены, что хотите покинуть эту группу?';
                        }
                    } else if (chat.type === 'channel') {
                        const channel = channels.find(c => c.id === chat.id);
                        if (channel && channel.creator === currentUser) {
                            confirmMessage = 'Вы уверены, что хотите удалить этот канал? Это действие необратимо.';
                        } else {
                            confirmMessage = 'Вы уверены, что хотите отписаться от этого канала?';
                        }
                    } else {
                        confirmMessage = 'Вы уверены, что хотите удалить этот чат? Все сообщения будут удалены.';
                    }
                    
                    if (confirm(confirmMessage)) {
                        deleteChatById(chat.id, chat.type);
                    }
                });
                
                searchResults.appendChild(userItem);
            });
        }
        
        async function deleteChatById(chatId, type) {
            try {
                if (type === 'group') {
                    const groupSnapshot = await database.ref('groups/' + chatId).once('value');
                    const group = groupSnapshot.val();
                    
                    if (group && group.admin === currentUser) {
                        await database.ref('groups/' + chatId).remove();
                        await database.ref('messages/' + chatId).remove();
                        showNotification('Группа удалена');
                    } else if (group && group.participants) {
                        const updatedParticipants = group.participants.filter(p => p !== currentUser);
                        await database.ref('groups/' + chatId).update({
                            participants: updatedParticipants
                        });
                        showNotification('Вы покинули группу');
                    } else {
                        showNotification('Группа не найдена');
                    }
                    
                    await loadGroups();
                } else if (type === 'channel') {
                    const channelSnapshot = await database.ref('channels/' + chatId).once('value');
                    const channel = channelSnapshot.val();
                    
                    if (channel && channel.creator === currentUser) {
                        await database.ref('channels/' + chatId).remove();
                        await database.ref('messages/' + chatId).remove();
                        showNotification('Канал удален');
                    } else {
                        await unsubscribeFromChannel(chatId);
                        showNotification('Вы отписались от канала');
                    }
                    
                    await loadChannels();
                } else {
                    // Удаляем сообщения
                    await database.ref('messages/' + chatId).remove();
                    
                    // Удаляем пользователя из recentChats
                    const otherUser = chatId.replace(currentUser, '').replace('_', '');
                    const userRef = database.ref('users/' + encodeURIComponent(currentUser));
                    const snapshot = await userRef.once('value');
                    const userData = snapshot.val();
                    
                    if (userData && userData.recentChats) {
                        const updatedRecentChats = userData.recentChats.filter(chat => chat.username !== otherUser);
                        await userRef.update({ recentChats: updatedRecentChats });
                        currentUserData.recentChats = updatedRecentChats;
                    }
                    
                    showNotification('Чат удален');
                }
                
                await loadRecentChats();
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function loadUsers() {
            // Показываем AI ассистента и подсказку для поиска
            searchResults.innerHTML = '';
            
            // Добавляем AI ассистента в начало списка
            const aiAssistantItem = document.createElement('div');
            aiAssistantItem.className = 'user-item';
            aiAssistantItem.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            aiAssistantItem.style.color = 'white';
            aiAssistantItem.style.marginBottom = '10px';
            aiAssistantItem.style.borderRadius = '8px';
            aiAssistantItem.innerHTML = `
                <div class="user-avatar" style="background: white; color: #667eea;">🤖</div>
                <div class="user-info">
                    <h3 style="color: white;">
                        <span class="user-emoji-small">🤖</span>
                        <span>AI Ассистент</span>
                        <span style="background: #2ecc71; color: white; font-size: 0.7rem; padding: 2px 6px; border-radius: 10px; margin-left: 8px;">Онлайн</span>
                    </h3>
                    <p style="color: rgba(255,255,255,0.8);">@ai_assistant</p>
                    <p style="color: rgba(255,255,255,0.9);">Задай мне любой вопрос!</p>
                </div>
            `;
            aiAssistantItem.addEventListener('click', () => openAIAssistantChat());
            searchResults.appendChild(aiAssistantItem);
            
            // Добавляем разделитель
            const divider = document.createElement('div');
            divider.style.padding = '10px 15px';
            divider.style.color = 'var(--text-light)';
            divider.style.fontSize = '0.85rem';
            divider.style.borderBottom = '1px solid var(--border-color)';
            divider.innerHTML = '🔍 Введите юзернейм для поиска пользователей';
            searchResults.appendChild(divider);
        }
        
        // Открыть чат с AI ассистентом
        function openAIAssistantChat() {
            currentChat = 'ai_assistant';
            currentChatType = 'ai';
            currentGroup = null;
            currentChannel = null;
            
            emptyState.style.display = 'none';
            chatHeader.style.display = 'flex';
            chatMessages.style.display = 'block';
            messageInputContainer.style.display = 'flex';
            
            chatAvatar.textContent = '🤖';
            chatUserName.innerHTML = `
                <span class="user-emoji-small">🤖</span>
                <span>AI Ассистент</span>
                <span style="background: #2ecc71; color: white; font-size: 0.7rem; padding: 2px 6px; border-radius: 10px; margin-left: 8px;">AI</span>
            `;
            
            // Скрываем кнопки блокировки и удаления для AI, показываем кнопку очистки
            blockUserBtn.style.display = 'none';
            deleteChatBtn.style.display = 'none';
            groupSettingsBtn.style.display = 'none';
            channelSettingsBtn.style.display = 'none';
            
            // Добавляем кнопку очистки истории если её ещё нет
            let clearHistoryBtn = document.getElementById('clear-history-btn');
            if (!clearHistoryBtn) {
                clearHistoryBtn = document.createElement('button');
                clearHistoryBtn.id = 'clear-history-btn';
                clearHistoryBtn.className = 'chat-header-btn';
                clearHistoryBtn.title = 'Очистить историю';
                clearHistoryBtn.innerHTML = '🗑️';
                clearHistoryBtn.style.color = '#e74c3c';
                chatHeader.querySelector('.chat-header-actions').appendChild(clearHistoryBtn);
            }
            clearHistoryBtn.style.display = 'block';
            clearHistoryBtn.onclick = clearAIChatHistory;
            
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('active');
            }
            
            loadAIMessages();
            
            // Добавляем приветственное сообщение если чат пустой
            const chatId = getChatId(currentUser, 'ai_assistant');
            database.ref('messages/' + chatId).once('value').then(snapshot => {
                if (!snapshot.exists()) {
                    const welcomeMessage = {
                        sender: 'ai_assistant',
                        text: 'Привет! Я AI ассистент. Я могу ответить на твои вопросы, помочь с переводом, написать текст или просто поболтать. Чем могу помочь?',
                        timestamp: Date.now()
                    };
                    database.ref('messages/' + chatId).push(welcomeMessage);
                    loadAIMessages();
                }
            });
            
            messageText.focus();
        }
        
        // Загрузка сообщений AI ассистента
        async function loadAIMessages() {
            if (!currentChat || currentChatType !== 'ai') return;
            
            try {
                const chatId = getChatId(currentUser, 'ai_assistant');
                const snapshot = await database.ref('messages/' + chatId).once('value');
                const messages = snapshot.val();
                displayMessages(messages, true);
            } catch (error) {
                console.error('Ошибка загрузки сообщений AI:', error);
            }
        }
        
        // Отправка сообщения AI ассистенту через OpenRouter
        async function sendMessageToAI(userMessage) {
            const chatId = getChatId(currentUser, 'ai_assistant');
            
            // Показываем индикатор "печатает"
            showNotification('AI думает...');
            
            try {
                // Используем OpenRouter API с зашифрованным ключом
                const apiKey = getAPIKey();
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey,
                        'HTTP-Referer': window.location.origin,
                        'X-Title': 'Twin Messenger AI'
                    },
                    body: JSON.stringify({
                        model: 'arcee-ai/trinity-mini:free',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a helpful AI assistant in a chat messenger. Respond in the same language as the user (Russian or English). Be friendly and concise.'
                            },
                            {
                                role: 'user',
                                content: userMessage
                            }
                        ],
                        max_tokens: 1000,
                        temperature: 0.7
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || 'Ошибка API');
                }
                
                const data = await response.json();
                console.log('OpenRouter response:', data);
                
                let aiResponse;
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    aiResponse = data.choices[0].message.content;
                } else if (data.choices && data.choices[0] && data.choices[0].text) {
                    aiResponse = data.choices[0].text;
                } else {
                    aiResponse = 'Извини, я не смог обработать твой запрос.';
                }
                
                // Сохраняем ответ AI
                const aiMessage = {
                    sender: 'ai_assistant',
                    text: aiResponse.trim(),
                    timestamp: Date.now()
                };
                
                await database.ref('messages/' + chatId).push(aiMessage);
                loadAIMessages();
                
            } catch (error) {
                console.error('Ошибка AI:', error);
                // Fallback ответ если API недоступен
                const fallbackMessage = {
                    sender: 'ai_assistant',
                    text: getFallbackResponse(userMessage),
                    timestamp: Date.now()
                };
                await database.ref('messages/' + chatId).push(fallbackMessage);
                loadAIMessages();
            }
        }
        
        // Очистка истории чата с AI
        async function clearAIChatHistory() {
            if (!confirm('Вы уверены, что хотите очистить историю переписки с AI?')) return;
            
            try {
                const chatId = getChatId(currentUser, 'ai_assistant');
                await database.ref('messages/' + chatId).remove();
                
                // Добавляем приветственное сообщение заново
                const welcomeMessage = {
                    sender: 'ai_assistant',
                    text: 'Привет! Я AI ассистент. Я могу ответить на твои вопросы, помочь с переводом, написать текст или просто поболтать. Чем могу помочь?',
                    timestamp: Date.now()
                };
                await database.ref('messages/' + chatId).push(welcomeMessage);
                
                loadAIMessages();
                showNotification('История переписки очищена');
            } catch (error) {
                console.error('Ошибка очистки истории:', error);
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        // Fallback ответы когда API недоступен
        function getFallbackResponse(message) {
            const lowerMsg = message.toLowerCase();
            
            if (lowerMsg.includes('привет') || lowerMsg.includes('здравствуй')) {
                return 'Привет! Как дела?';
            } else if (lowerMsg.includes('как дела')) {
                return 'У меня всё отлично, спасибо! А у тебя?';
            } else if (lowerMsg.includes('пока') || lowerMsg.includes('до свидания')) {
                return 'До свидания! Хорошего дня!';
            } else if (lowerMsg.includes('спасибо')) {
                return 'Пожалуйста! Обращайся ещё!';
            } else if (lowerMsg.includes('помоги') || lowerMsg.includes('помощь')) {
                return 'Я готов помочь! Опиши, что тебе нужно.';
            } else if (lowerMsg.includes('шутк') || lowerMsg.includes('анекдот')) {
                return 'Знаешь почему программисты путают Хэллоуин и Рождество? Потому что 31 OCT = 25 DEC!';
            } else if (lowerMsg.includes('время') || lowerMsg.includes('дата')) {
                return 'Сейчас ' + new Date().toLocaleString('ru-RU');
            } else if (lowerMsg.includes('переведи') || lowerMsg.includes('перевод')) {
                return 'Я могу помочь с переводом! Напиши текст, который нужно перевести.';
            } else if (lowerMsg.includes('кто ты')) {
                return 'Я AI ассистент в этом мессенджере. Я могу отвечать на вопросы и помогать с разными задачами!';
            } else {
                return 'Интересно! Расскажи подробнее, или задай мне конкретный вопрос.';
            }
        }
        
        // Получение API ключа (обфусцированный)
        function getAPIKey() {
            // Разбиваем ключ на части и декодируем из base64
            const parts = [
                'c2stb3ItdjEtOTY2ZTk0OGNmYmIzMGViOWUxOGMxYjFlN2M4MjBlOWJhYjA5YTA3YjE4OTE3Zjg3N2NhNGRiYzQwMjhlMDgxNg=='
            ];
            return atob(parts[0]);
        }

        // Функция для отслеживания статуса других пользователей
function trackUserStatus() {
    if (!currentUser) return;
    
    // Следим за изменениями статусов всех пользователей
    database.ref('users').on('child_changed', (snapshot) => {
        const userData = snapshot.val();
        const username = userData ? userData.username : null;
        
        // Не показываем уведомления о себе
        if (username && username !== currentUser && userData) {
            if (userData.online) {
                showNotification(`🟢 ${userData.name || username} появился в сети`);
            } else {
                showNotification(`🔴 ${userData.name || username} вышел из сети`);
            }
        }
    });
}
        
        function displayUsers(users) {
            searchResults.innerHTML = '';
            
            if (!users) {
                searchResults.innerHTML = '<div class="user-item">Пользователи не найдены</div>';
                return;
            }
            
            Object.keys(users).forEach(key => {
                const user = users[key];
                if (key !== currentUser && user && user.username) {
                    const isBlocked = blockedUsers.includes(key);
                    
                    const userItem = document.createElement('div');
                    userItem.className = 'user-item';
                    userItem.innerHTML = `
                        <div class="user-avatar">${(user.name || user.username).charAt(0).toUpperCase()}</div>
                        <div class="user-info">
                            <h3>
                                <span class="user-emoji-small">${user.emoji || '😊'}</span>
                                <span>${escapeHtml(user.name || user.username)}</span>
                                ${isBlocked ? '<span style="color: var(--danger-color); margin-left: 5px;">(Заблокирован)</span>' : ''}
                            </h3>
                            <p style="font-size: 0.75rem; color: var(--text-light);">@${user.username}</p>
                            <p>${user.online ? 'Онлайн' : formatLastSeen(user.lastSeen)}</p>
                        </div>
                    `;
                    
                    if (!isBlocked) {
                        userItem.addEventListener('click', () => addUserToChatsAndOpen(user));
                    }
                    
                    searchResults.appendChild(userItem);
                }
            });
        }
        
        // Добавить пользователя в чаты и открыть чат
        async function addUserToChatsAndOpen(user) {
            if (!currentUser || !user) return;
            
            // Добавляем пользователя в список недавних чатов
            try {
                const userRef = database.ref('users/' + encodeURIComponent(currentUser));
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();
                
                let recentChats = userData.recentChats || [];
                
                // Проверяем, есть ли уже этот чат
                const existingIndex = recentChats.findIndex(chat => chat.username === user.username);
                if (existingIndex === -1) {
                    recentChats.push({
                        username: user.username,
                        name: user.name,
                        emoji: user.emoji || '😊',
                        addedAt: Date.now()
                    });
                    
                    await userRef.update({ recentChats: recentChats });
                }
                
                // Открываем чат
                openChat(user.username, user.emoji || '😊', user.name);
                
                // Переключаемся на вкладку чатов
                switchTab('chats');
            } catch (error) {
                console.error('Ошибка добавления в чаты:', error);
                openChat(user.username, user.emoji || '😊', user.name);
            }
        }
        
        function formatLastSeen(timestamp) {
            if (!timestamp) return 'Был(а) давно';
            
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / (1000 * 60));
            
            if (minutes < 1) return 'Только что';
            if (minutes < 60) return `Был(а) ${minutes} мин назад`;
            
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `Был(а) ${hours} ч назад`;
            
            const days = Math.floor(hours / 24);
            return `Был(а) ${days} д назад`;
        }
        
        async function handleSearch() {
            const query = searchInput.value.toLowerCase().trim();
            
            if (query === '') {
                if (activeTab === 'chats') {
                    loadRecentChats();
                } else if (activeTab === 'users') {
                    loadUsers();
                } else if (activeTab === 'channels') {
                    loadChannels();
                }
                return;
            }
            
            try {
                if (activeTab === 'users') {
                    // Поиск только по username (точное или частичное совпадение)
                    const snapshot = await database.ref('users').once('value');
                    const users = snapshot.val();
                    searchResults.innerHTML = '';
                    
                    if (!users) {
                        searchResults.innerHTML = '<div class="user-item">Пользователи не найдены</div>';
                        return;
                    }
                    
                    let foundUsers = 0;
                    Object.keys(users).forEach(key => {
                        const user = users[key];
                        // Ищем только по username (точное совпадение)
                        if (key !== currentUser && user && user.username && 
                            user.username.toLowerCase() === query) {
                            foundUsers++;
                            const isBlocked = blockedUsers.includes(key);
                            
                            const userItem = document.createElement('div');
                            userItem.className = 'user-item';
                            userItem.innerHTML = `
                                <div class="user-avatar">${(user.name || user.username).charAt(0).toUpperCase()}</div>
                                <div class="user-info">
                                    <h3>
                                        <span class="user-emoji-small">${user.emoji || '😊'}</span>
                                        <span>${escapeHtml(user.name || user.username)}</span>
                                        ${isBlocked ? '<span style="color: var(--danger-color); margin-left: 5px;">(Заблокирован)</span>' : ''}
                                    </h3>
                                    <p style="font-size: 0.75rem; color: var(--text-light);">@${user.username}</p>
                                    <p>${user.online ? 'Онлайн' : formatLastSeen(user.lastSeen)}</p>
                                </div>
                            `;
                            
                            if (!isBlocked) {
                                userItem.addEventListener('click', () => addUserToChatsAndOpen(user));
                            }
                            
                            searchResults.appendChild(userItem);
                        }
                    });
                    
                    if (foundUsers === 0) {
                        searchResults.innerHTML = '<div class="user-item" style="text-align: center; color: var(--text-light);">Пользователи не найдены</div>';
                    }
                } else if (activeTab === 'channels') {
                    const snapshot = await database.ref('channels').once('value');
                    const allChannels = snapshot.val();
                    searchResults.innerHTML = '';
                    
                    if (!allChannels) {
                        searchResults.innerHTML = '<div class="user-item">Каналы не найдены</div>';
                        return;
                    }
                    
                    Object.keys(allChannels).forEach(channelId => {
                        const channel = allChannels[channelId];
                        if (channel && channel.name && 
                            channel.name.toLowerCase().includes(query)) {
                            
                            const channelItem = document.createElement('div');
                            channelItem.className = 'channel-item';
                            
                            const isSubscribed = subscribedChannels.includes(channelId);
                            const iconHtml = getChannelIconHtml(channel);
                            
                            channelItem.innerHTML = `
                                <div class="channel-icon">${iconHtml}</div>
                                <div class="channel-info">
                                    <h3>${escapeHtml(channel.name)}</h3>
                                    <p>${escapeHtml(channel.description || 'Нет описания')}</p>
                                    <div class="channel-subscribers">
                                        <span>👤 ${channel.subscribers ? channel.subscribers.length : 0}</span>
                                    </div>
                                </div>
                                <button class="subscribe-btn ${isSubscribed ? 'subscribed' : ''}" data-channel-id="${channelId}">
                                    ${isSubscribed ? 'Отписаться' : 'Подписаться'}
                                </button>
                            `;
                            
                            const subscribeBtn = channelItem.querySelector('.subscribe-btn');
                            subscribeBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                toggleSubscribe(channelId);
                            });
                            
                            channelItem.addEventListener('click', () => {
                                if (isSubscribed) {
                                    openChannelChat(channelId, channel.name);
                                } else {
                                    showNotification('Подпишитесь на канал, чтобы просматривать сообщения');
                                }
                            });
                            
                            searchResults.appendChild(channelItem);
                        }
                    });
                }
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        function openChat(username, emoji = '😊', displayName = null) {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('active');
                mobileTitle.textContent = displayName || username;
            }
            
            if (currentChat && messageListeners[currentChat]) {
                clearInterval(messageListeners[currentChat]);
            }
            
            currentChat = username;
            currentChatType = 'user';
            currentGroup = null;
            currentChannel = null;
            emptyState.style.display = 'none';
            chatHeader.style.display = 'flex';
            chatMessages.style.display = 'block';
            messageInputContainer.style.display = 'flex';
            
            chatUserEmoji.textContent = emoji;
            chatUserName.querySelector('span:last-child').textContent = displayName || username;
            chatAvatar.textContent = (displayName || username).charAt(0).toUpperCase();
            
            blockUserBtn.style.display = 'block';
            deleteChatBtn.style.display = 'block';
            groupSettingsBtn.style.display = 'none';
            channelSettingsBtn.style.display = 'none';
            
            // Показываем кнопки профиля и подарков для личных чатов
            document.getElementById('view-profile-btn').style.display = 'block';
            document.getElementById('send-gift-btn').style.display = 'block';
            
            // Показываем кнопку звонка только для личных чатов
            document.getElementById('audio-call-btn').style.display = 'block';
            
            // Скрываем кнопку очистки истории AI
            const clearHistoryBtn = document.getElementById('clear-history-btn');
            if (clearHistoryBtn) clearHistoryBtn.style.display = 'none';
            
            if (blockedUsers.includes(username)) {
                blockUserBtn.innerHTML = '🔓';
                blockUserBtn.title = 'Разблокировать пользователя';
            } else {
                blockUserBtn.innerHTML = '🚫';
                blockUserBtn.title = 'Заблокировать пользователя';
            }
            
            adjustMessageInput();
            
            loadMessages();
            
            messageListeners[username] = setInterval(() => {
                loadMessages();
            }, 3000);
        }
        
        function closeChat() {
            if (window.innerWidth <= 768) {
                emptyState.style.display = 'flex';
                chatHeader.style.display = 'none';
                chatMessages.style.display = 'none';
                messageInputContainer.style.display = 'none';
                mobileTitle.textContent = 'Twin';
                openSidebar();
            } else {
                emptyState.style.display = 'flex';
                chatHeader.style.display = 'none';
                chatMessages.style.display = 'none';
                messageInputContainer.style.display = 'none';
            }
            
            if (currentChat && messageListeners[currentChat]) {
                clearInterval(messageListeners[currentChat]);
                delete messageListeners[currentChat];
            }
            
            // Hide gift and profile buttons
            document.getElementById('view-profile-btn').style.display = 'none';
            document.getElementById('send-gift-btn').style.display = 'none';
            
            currentChat = null;
            currentChatType = null;
            currentGroup = null;
            currentChannel = null;
        }
        
        async function loadMessages() {
            if (!currentChat) return;
            
            // Для AI чата используем специальную функцию
            if (currentChatType === 'ai') {
                loadAIMessages();
                return;
            }
            
            try {
                let chatId;
                if (currentChatType === 'group' || currentChatType === 'channel') {
                    chatId = currentChat;
                } else {
                    chatId = getChatId(currentUser, currentChat);
                }
                
                const snapshot = await database.ref('messages/' + chatId).once('value');
                const messages = snapshot.val();
                
                if (currentChatType === 'channel') {
                    displayMessages(messages, false);
                } else {
                    displayMessages(messages, true);
                }
            } catch (error) {
                console.error('Ошибка загрузки сообщений:', error);
                showNotification('Ошибка загрузки сообщений: ' + error.message);
            }
        }
        
        function displayMessages(messages, autoScroll = true) {
            chatMessages.innerHTML = '';
            
            if (!messages) {
                chatMessages.innerHTML = '<div class="message"><div class="message-content">Нет сообщений</div></div>';
                return;
            }
            
            const messagesArray = Object.keys(messages).map(key => ({
                id: key,
                ...messages[key]
            }));
            
            const filteredMessages = messagesArray.filter(message => {
                if (currentChatType === 'user') {
                    return !blockedUsers.includes(message.sender);
                }
                return true;
            });
            
            const sortedMessages = filteredMessages
                .filter(msg => msg.text && msg.sender && msg.timestamp)
                .sort((a, b) => {
                    if (a.timestamp !== b.timestamp) {
                        return a.timestamp - b.timestamp;
                    }
                    return a.id.localeCompare(b.id);
                });
            
            if (sortedMessages.length === 0) {
                chatMessages.innerHTML = '<div class="message"><div class="message-content">Нет сообщений</div></div>';
                return;
            }
            
            let messagesHTML = '';
            let lastDate = null;
            
            sortedMessages.forEach(message => {
                const messageDate = new Date(message.timestamp);
                const dateString = messageDate.toLocaleDateString();
                
                if (dateString !== lastDate) {
                    messagesHTML += `
                        <div style="text-align: center; margin: 15px 0;">
                            <span style="background: var(--message-hover); padding: 5px 10px; border-radius: 10px; font-size: 0.8rem;">
                                ${dateString}
                            </span>
                        </div>
                    `;
                    lastDate = dateString;
                }
                
                const timeString = messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const isSent = message.sender === currentUser;
                
                const actionsHTML = isSent ? `
                    <div class="message-actions">
                        <button class="message-action-btn" onclick="editMessage('${message.id}', '${escapeHtml(message.text).replace(/'/g, "\\'")}')">✏️</button>
                        <button class="message-action-btn" onclick="deleteMessage('${message.id}')">🗑️</button>
                    </div>
                ` : '';
                
                let senderName = '';
                if ((currentChatType === 'group' || currentChatType === 'channel') && !isSent) {
                    senderName = `<div style="font-size: 0.8rem; margin-bottom: 3px; color: var(--text-light);">${escapeHtml(message.sender)}</div>`;
                }
                
                const editedMark = message.edited ? ' <span style="font-size: 0.7rem; color: var(--text-light);">(изменено)</span>' : '';
                
                messagesHTML += `
                    <div class="message ${isSent ? 'sent' : 'received'}">
                        ${senderName}
                        <div class="message-content">${escapeHtml(message.text)}${editedMark}</div>
                        <div class="message-time">${timeString}</div>
                        ${actionsHTML}
                    </div>
                `;
            });
            
            chatMessages.innerHTML = messagesHTML;
            
            if (autoScroll) {
                scrollToBottom();
            }
        }
        
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        
        function scrollToBottom() {
            const isScrolledToBottom = chatMessages.scrollHeight - chatMessages.clientHeight <= chatMessages.scrollTop + 50;
            
            if (isScrolledToBottom || !currentChat) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                if (window.innerWidth <= 768) {
                    setTimeout(() => {
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }, 100);
                }
            }
        }
        
        async function sendMessage() {
            const text = messageText.value.trim();
            if (!text || !currentChat) return;
            
            // Обработка сообщений для AI ассистента
            if (currentChatType === 'ai') {
                const chatId = getChatId(currentUser, 'ai_assistant');
                
                const message = {
                    sender: currentUser,
                    text: text,
                    timestamp: Date.now()
                };
                
                try {
                    // Сохраняем сообщение пользователя
                    await database.ref('messages/' + chatId).push(message);
                    messageText.value = '';
                    autoResizeTextarea();
                    loadAIMessages();
                    
                    // Отправляем запрос к AI
                    await sendMessageToAI(text);
                    
                    messageText.focus();
                    lastMessageTimestamp = message.timestamp;
                } catch (error) {
                    showNotification('Ошибка: ' + error.message);
                }
                return;
            }
            
            let chatId;
            if (currentChatType === 'group' || currentChatType === 'channel') {
                chatId = currentChat;
            } else {
                chatId = getChatId(currentUser, currentChat);
            }
            
            if (currentChatType === 'channel') {
                const channel = channels.find(c => c.id === chatId);
                if (!channel || channel.creator !== currentUser) {
                    showNotification('Только создатель канала может отправлять сообщения');
                    return;
                }
            }
            
            // Проверка на команду повтора #povtors
            const povtorsMatch = text.match(/^#povtors\s+(\d+)\s+(.+)$/i);
            if (povtorsMatch) {
                const count = parseInt(povtorsMatch[1]);
                const messageToRepeat = povtorsMatch[2].trim();
                
                if (count < 1 || count > 100) {
                    showNotification('Количество повторов должно быть от 1 до 100');
                    return;
                }
                
                if (!messageToRepeat) {
                    showNotification('Введите сообщение для повтора');
                    return;
                }
                
                messageText.value = '';
                autoResizeTextarea();
                await sendRepeatedMessages(chatId, messageToRepeat, count);
                return;
            }
            
            const message = {
                sender: currentUser,
                text: text,
                timestamp: Date.now()
            };
            
            if (currentChatType === 'user') {
                message.receiver = currentChat;
            }
            
            try {
                await database.ref('messages/' + chatId).push(message);
                
                // Создаем уведомление для получателя(ей)
                await createNotificationForReceiver(text);
                
                messageText.value = '';
                autoResizeTextarea();
                
                loadMessages();
                
                if (activeTab === 'chats') {
                    loadRecentChats();
                }
                
                messageText.focus();
                
                lastMessageTimestamp = message.timestamp;
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        // Отправка повторяющихся сообщений
        async function sendRepeatedMessages(chatId, text, count) {
            try {
                showNotification(`Отправка ${count} сообщений...`);
                
                for (let i = 0; i < count; i++) {
                    const message = {
                        sender: currentUser,
                        text: text,
                        timestamp: Date.now() + i // Добавляем i для уникальности timestamp
                    };
                    
                    if (currentChatType === 'user') {
                        message.receiver = currentChat;
                    }
                    
                    await database.ref('messages/' + chatId).push(message);
                    
                    // Небольшая задержка между сообщениями для корректной сортировки
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // Создаем уведомление для получателя(ей)
                await createNotificationForReceiver(`${text} (x${count})`);
                
                loadMessages();
                
                if (activeTab === 'chats') {
                    loadRecentChats();
                }
                
                messageText.focus();
                
                showNotification(`Отправлено ${count} сообщений`);
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        // Создание уведомления для получателя
        async function createNotificationForReceiver(text) {
            if (!currentChat) return;
            
            try {
                if (currentChatType === 'user') {
                    // Личное сообщение - создаем уведомление для собеседника
                    const receiverNotificationsRef = database.ref('users/' + encodeURIComponent(currentChat) + '/notifications');
                    await receiverNotificationsRef.push({
                        type: 'message',
                        from: currentUser,
                        text: text,
                        timestamp: Date.now(),
                        read: false
                    });
                } else if (currentChatType === 'group') {
                    // Групповое сообщение - создаем уведомление для всех участников
                    if (currentGroup && currentGroup.participants) {
                        for (const participant of currentGroup.participants) {
                            if (participant !== currentUser) {
                                const participantNotificationsRef = database.ref('users/' + encodeURIComponent(participant) + '/notifications');
                                await participantNotificationsRef.push({
                                    type: 'message',
                                    from: currentUser,
                                    groupName: currentGroup.name,
                                    text: text,
                                    timestamp: Date.now(),
                                    read: false
                                });
                            }
                        }
                    }
                } else if (currentChatType === 'channel') {
                    // Канал - создаем уведомление для всех подписчиков
                    if (currentChannel && currentChannel.subscribers) {
                        for (const subscriber of currentChannel.subscribers) {
                            if (subscriber !== currentUser) {
                                const subscriberNotificationsRef = database.ref('users/' + encodeURIComponent(subscriber) + '/notifications');
                                await subscriberNotificationsRef.push({
                                    type: 'message',
                                    from: currentUser,
                                    channelName: currentChannel.name,
                                    text: text,
                                    timestamp: Date.now(),
                                    read: false
                                });
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Ошибка создания уведомления:', error);
            }
        }
        
        function getChatId(user1, user2) {
            return [user1, user2].sort().join('_');
        }
        
        window.editMessage = function(messageId, text) {
            editingMessageId = messageId;
            editMessageText.value = unescapeHtml(text);
            editMessageModal.classList.add('active');
        };
        
        function closeEditMessage() {
            editMessageModal.classList.remove('active');
            editingMessageId = null;
        }
        
        async function saveEditedMessage() {
            if (!editingMessageId || !currentChat) return;
            
            const newText = editMessageText.value.trim();
            if (!newText) {
                showNotification('Сообщение не может быть пустым');
                return;
            }
            
            try {
                let chatId;
                if (currentChatType === 'group' || currentChatType === 'channel') {
                    chatId = currentChat;
                } else {
                    chatId = getChatId(currentUser, currentChat);
                }
                
                await database.ref('messages/' + chatId + '/' + editingMessageId).update({
                    text: newText,
                    edited: true
                });
                
                closeEditMessage();
                loadMessages();
                
                if (activeTab === 'chats') {
                    loadRecentChats();
                }
                
                showNotification('Сообщение отредактировано');
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        window.deleteMessage = async function(messageId) {
            if (!confirm('Вы уверены, что хотите удалить это сообщение?')) return;
            
            try {
                let chatId;
                if (currentChatType === 'group' || currentChatType === 'channel') {
                    chatId = currentChat;
                } else {
                    chatId = getChatId(currentUser, currentChat);
                }
                
                await database.ref('messages/' + chatId + '/' + messageId).remove();
                
                loadMessages();
                
                if (activeTab === 'chats') {
                    loadRecentChats();
                }
                
                showNotification('Сообщение удалено');
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        };
        
        function unescapeHtml(safe) {
            return safe
                .replace(/&amp;/g, "&")
                .replace(/&lt;/g, "<")
                .replace(/&gt;/g, ">")
                .replace(/&quot;/g, "\"")
                .replace(/&#039;/g, "'");
        }
        
        // Gift types
        const giftTypes = {
            'rose': { icon: '🌹', name: 'Роза', price: 1 },
            'heart': { icon: '❤️', name: 'Сердце', price: 1 },
            'star': { icon: '⭐', name: 'Звезда', price: 1 },
            'fire': { icon: '🔥', name: 'Огонь', price: 1 },
            'gem': { icon: '💎', name: 'Кристалл', price: 1 },
            'trophy': { icon: '🏆', name: 'Трофей', price: 1 },
            'gift': { icon: '🎁', name: 'Подарок', price: 1 },
            'pizza': { icon: '🍕', name: 'Пицца', price: 1 },
            'coffee': { icon: '☕', name: 'Кофе', price: 1 },
            'beer': { icon: '🍺', name: 'Пиво', price: 1 }
        };
        
        // Total gifts available in the marketplace
        let totalMarketplaceGifts = 1000; // Limited number of gifts in the marketplace
        
        // Track gifts sent per user per day
        let dailyGiftsTracker = {};
        
        
        
        // Initialize user gifts if not present
        async function initializeUserGifts() {
            try {
                const userSnapshot = await database.ref('users/' + encodeURIComponent(currentUser)).once('value');
                const userData = userSnapshot.val();
                
                if (!userData || !userData.gifts) {
                    // Initialize with default gifts
                    const defaultGifts = { 'heart': 2, 'rose': 2 };
                    await database.ref('users/' + encodeURIComponent(currentUser)).update({
                        gifts: defaultGifts
                    });
                    return defaultGifts;
                }
                
                return userData.gifts;
            } catch (error) {
                console.error('Error initializing user gifts:', error);
                // Return default gifts in case of error
                return { 'heart': 2, 'rose': 2 };
            }
        }
        
        // Initialize and manage daily gift tracker
        function initializeDailyGiftTracker() {
            // Check if we need to reset the daily tracker (if it's a new day)
            const today = new Date().toDateString();
            
            // Clean up old entries (older than a day)
            for (const key in dailyGiftsTracker) {
                const keyDate = key.split('_')[1];
                const trackerDate = new Date(keyDate).toDateString();
                
                if (trackerDate !== today) {
                    delete dailyGiftsTracker[key];
                }
            }
        }
        
        // Call this function periodically to clean up old entries
        setInterval(initializeDailyGiftTracker, 60000); // Run every minute
        
        // Check if user can send gift to another user today
        function canSendGiftToUser(username) {
            const today = new Date().toDateString();
            const lastSentDate = sentGiftsToday[username] ? new Date(sentGiftsToday[username]).toDateString() : null;
            
            return lastSentDate !== today && giftCount > 0;
        }
        
        // Send gift to user
        async function sendGiftToUser(username, giftType = 'rose') {
            try {
                // Validate gift type
                if (!giftTypes[giftType]) {
                    showNotification(`Недопустимый тип подарка: ${giftType}`);
                    return false;
                }
                
                // Check if user has already sent a gift today (FREE once per day)
                const today = new Date().toDateString();
                const key = `${currentUser}_${today}`;
                
                if (dailyGiftsTracker[key] && dailyGiftsTracker[key].count >= 1) {
                    showNotification(`Вы уже отправили подарок сегодня! Можете отправить только один подарок в день.`);
                    return false;
                }
                
                // NEW: Now gifts are FREE - no need to check user's inventory
                // The system allows sending any gift for free once per day
                
                // Update daily tracker
                if (!dailyGiftsTracker[key]) {
                    dailyGiftsTracker[key] = { count: 0, recipients: [] };
                }
                
                // Check if user has already sent a gift to this recipient today
                if (dailyGiftsTracker[key].recipients.includes(username)) {
                    showNotification(`Вы уже отправили подарок этому пользователю сегодня!`);
                    return false;
                }
                
                // Update the tracker
                dailyGiftsTracker[key].count++;
                dailyGiftsTracker[key].recipients.push(username);
                
                // Save gift to recipient's collection
                const gift = {
                    id: Date.now(),
                    sender: currentUser,
                    receiver: username,
                    type: giftType,
                    icon: giftTypes[giftType].icon,
                    name: giftTypes[giftType].name,
                    timestamp: Date.now()
                };
                
                // Add gift to recipient's collection
                const userGiftsRef = database.ref('users/' + encodeURIComponent(username) + '/gifts');
                await userGiftsRef.push(gift);
                
                // Create notification for recipient
                const recipientNotificationsRef = database.ref('users/' + encodeURIComponent(username) + '/notifications');
                await recipientNotificationsRef.push({
                    type: 'gift',
                    from: currentUser,
                    gift: gift,
                    text: `Пользователь ${currentUser} отправил вам подарок ${giftTypes[giftType].icon}!`,
                    timestamp: Date.now(),
                    read: false
                });
                
                showNotification(`Подарок ${giftTypes[giftType].icon} отправлен пользователю ${username}! (Бесплатно)`);
                
                // If we're in the chat with this user, show a message
                if (currentChat === username && currentChatType === 'user') {
                    const chatId = getChatId(currentUser, username);
                    const message = {
                        sender: currentUser,
                        text: `🎁 Я отправил(а) вам подарок ${giftTypes[giftType].icon}! (Бесплатно)`,
                        timestamp: Date.now(),
                        isGift: true,
                        gift: gift
                    };
                    await database.ref('messages/' + chatId).push(message);
                    loadMessages();
                }
                
                // Update gift display
                loadUserGiftsDisplay();
                
                return true;
            } catch (error) {
                console.error('Error sending gift:', error);
                showNotification('Ошибка при отправке подарка: ' + error.message);
                return false;
            }
        }
        
        // Open gift marketplace
        function openGiftMarketplace() {
            // Create modal for gift marketplace
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.id = 'gift-marketplace-modal';
            
            // Check if user has already sent a gift today
            const today = new Date().toDateString();
            const key = `${currentUser}_${today}`;
            const hasSentGiftToday = dailyGiftsTracker[key] && dailyGiftsTracker[key].count >= 1;
            
            // Build gift items HTML
            let giftItemsHtml = '';
            for (const [type, giftInfo] of Object.entries(giftTypes)) {
                // Disable button if user has already sent a gift today
                const disabledAttr = hasSentGiftToday ? 'disabled' : '';
                const disabledStyle = hasSentGiftToday ? 'opacity: 0.6; cursor: not-allowed;' : '';
                
                giftItemsHtml += `
                    <div class="gift-type-item" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid var(--border-color);">
                        <span style="font-size: 2.5rem; margin-right: 15px;">${giftInfo.icon}</span>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 1.1rem;">${giftInfo.name}</div>
                            <div style="font-size: 0.8rem; color: var(--text-light);">Цена: ${giftInfo.price} шт. (БЕСПЛАТНО сегодня)</div>
                        </div>
                        <button class="modal-btn modal-btn-primary gift-buy-btn" data-gift-type="${type}" style="min-width: 80px; padding: 8px 12px; font-size: 0.9rem; ${disabledStyle}" ${disabledAttr}>
                            Отправить
                        </button>
                    </div>`;
            }
            
            // Status message about daily limit
            const statusMessage = hasSentGiftToday 
                ? '<div style="color: var(--danger-color); font-weight: bold; margin: 10px 0; text-align: center;">⚠️ Вы уже отправили подарок сегодня</div>'
                : '<div style="color: var(--success-color); margin: 10px 0; text-align: center;">✅ Вы можете отправить один подарок сегодня</div>';
            
            modal.innerHTML = `
                <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                    <h2 class="modal-title">🎁 Магазин подарков</h2>
                    <div style="margin-bottom: 15px; padding: 12px; background: var(--message-hover); border-radius: 8px;">
                        <strong>Ваши подарки:</strong><br>
                        <span id="user-gifts-display">Загрузка...</span><br>
                        <small style="color: var(--text-light); font-size: 0.8em; display: block; margin-top: 5px;">💡 Сегодня вы можете отправить один бесплатный подарок любому пользователю</small>
                    </div>
                    ${statusMessage}
                    <div class="gift-types-container">
                        <h3>Доступные подарки:</h3>
                        ${giftItemsHtml}
                    </div>
                    <div class="modal-actions" style="margin-top: 15px;">
                        <button class="modal-btn modal-btn-secondary" id="close-marketplace-btn">Закрыть</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Load user's gifts
            loadUserGiftsDisplay();
            
            // Add event listeners
            document.getElementById('close-marketplace-btn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            // Add event listeners for gift buy buttons
            document.querySelectorAll('.gift-buy-btn:not([disabled])').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const giftType = e.target.getAttribute('data-gift-type');
                    
                    // Get the current chat user
                    if (!currentChat || currentChatType !== 'user') {
                        showNotification('Подарки можно отправлять только в личных чатах!');
                        return;
                    }
                    
                    // NEW: Gifts are free now, so no need to check user's inventory
                    // Send gift
                    const success = await sendGiftToUser(currentChat, giftType);
                    if (success) {
                        // Rebuild the modal to reflect the new state
                        document.body.removeChild(modal);
                        openGiftMarketplace();
                    }
                });
            });
        }
        
        // Load and display user's gifts
        async function loadUserGiftsDisplay() {
            try {
                // Get user's gift inventory from Firebase
                const userSnapshot = await database.ref('users/' + encodeURIComponent(currentUser)).once('value');
                const userData = userSnapshot.val();
                const userGifts = userData.gifts || { 'heart': 2 };
                
                const displayElement = document.getElementById('user-gifts-display');
                
                if (displayElement) {
                    let giftsHtml = '';
                    for (const [type, count] of Object.entries(userGifts)) {
                        giftsHtml += `${giftTypes[type].icon} ${giftTypes[type].name}: ${count}<br>`;
                    }
                    displayElement.innerHTML = giftsHtml || 'У вас пока нет подарков';
                    
                    // Add explanation that regardless of owned gifts, user can send one free gift today
                    const today = new Date().toDateString();
                    const key = `${currentUser}_${today}`;
                    const hasSentGiftToday = dailyGiftsTracker[key] && dailyGiftsTracker[key].count >= 1;
                    
                    if (!hasSentGiftToday) {
                        displayElement.innerHTML += '<br><small style="color: var(--success-color);">💡 Сегодня вы можете отправить один бесплатный подарок</small>';
                    } else {
                        displayElement.innerHTML += '<br><small style="color: var(--danger-color);">💡 Сегодня вы уже отправили подарок</small>';
                    }
                }
            } catch (error) {
                console.error('Error loading user gifts display:', error);
            }
        }
        
        // Load gifts for a user
        async function loadUserGifts(username) {
            try {
                const snapshot = await database.ref('users/' + encodeURIComponent(username) + '/gifts').once('value');
                const gifts = snapshot.val();
                
                if (gifts) {
                    // Filter out invalid gift objects and sort by timestamp
                    const validGifts = Object.values(gifts)
                        .filter(gift => gift && gift.icon && gift.sender && gift.timestamp)
                        .sort((a, b) => b.timestamp - a.timestamp);
                    
                    return validGifts;
                }
                
                return [];
            } catch (error) {
                console.error('Error loading user gifts:', error);
                return [];
            }
        }
        
        // Display gifts in the profile modal
        function displayUserGifts(gifts) {
            const giftsList = document.getElementById('gifts-list');
            
            if (!giftsList) return;
            
            if (gifts.length === 0) {
                giftsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-light); font-style: italic;">Нет полученных подарков</div>';
                return;
            }
            
            giftsList.innerHTML = '';
            
            gifts.forEach(gift => {
                // Check if gift object has required properties to avoid undefined values
                if (!gift || !gift.icon || !gift.sender || !gift.timestamp) {
                    console.warn('Invalid gift object:', gift);
                    return;
                }
                
                const giftDate = new Date(gift.timestamp);
                const giftItem = document.createElement('div');
                giftItem.className = 'gift-item';
                giftItem.style.cssText = 'display: flex; align-items: center; padding: 12px; border-radius: 8px; margin-bottom: 8px; background: var(--input-bg); border: 1px solid var(--border-color);';
                
                // Safely access gift properties
                const giftIcon = gift.icon || '🎁';
                const giftSender = gift.sender || 'Неизвестный';
                
                giftItem.innerHTML = `
                    <div class="gift-icon" style="font-size: 2.5rem; margin-right: 15px;">${giftIcon}</div>
                    <div class="gift-info" style="flex: 1;">
                        <div class="gift-sender" style="font-weight: bold; color: var(--primary-color); margin-bottom: 3px;">${giftSender}</div>
                        <div class="gift-date" style="font-size: 0.85rem; color: var(--text-light);">${giftDate.toLocaleDateString()} ${giftDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                    </div>
                `;
                giftsList.appendChild(giftItem);
            });
        }
        
        // View user profile and gifts
        async function viewUserProfile(username) {
            try {
                const userRef = database.ref('users/' + encodeURIComponent(username));
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();
                
                if (!userData) {
                    showNotification('Пользователь не найден');
                    return;
                }
                
                // Fill profile information
                const profileAvatar = document.getElementById('profile-avatar');
                const profileName = document.getElementById('profile-name');
                const profileUsername = document.getElementById('profile-username');
                const profileStatus = document.getElementById('profile-status');
                
                if (profileAvatar) {
                    profileAvatar.textContent = (userData.name || username).charAt(0).toUpperCase();
                }
                if (profileName) {
                    profileName.textContent = userData.name || username;
                }
                if (profileUsername) {
                    profileUsername.textContent = '@' + username;
                }
                if (profileStatus) {
                    profileStatus.textContent = `${userData.emoji || '😊'} ${(userData.online ? '🟢 Онлайн' : '🔴 Офлайн')}`;
                }
                
                // Load and display gifts
                const gifts = await loadUserGifts(username);
                displayUserGifts(gifts);
                
                // Show the modal
                document.getElementById('profile-view-modal').classList.add('active');
            } catch (error) {
                console.error('Error viewing user profile:', error);
                showNotification('Ошибка при просмотре профиля: ' + error.message);
            }
        }
        
        // Load and display user's own gifts in profile settings
        async function loadMyGifts() {
            if (!currentUser) return;
            
            try {
                const gifts = await loadUserGifts(currentUser);
                displayMyGifts(gifts);
                
                // Hide the received gifts section if user has no gifts
                const giftsSection = document.querySelector('.user-gifts-section');
                if (giftsSection) {
                    if (gifts.length === 0) {
                        giftsSection.style.display = 'none';
                    } else {
                        giftsSection.style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('Error loading my gifts:', error);
            }
        }
        
        // Display my gifts in the profile settings modal
        function displayMyGifts(gifts) {
            const myGiftsList = document.getElementById('my-gifts-list');
            
            if (!myGiftsList) return;
            
            if (gifts.length === 0) {
                myGiftsList.innerHTML = '<div style="text-align: center; padding: 10px; color: var(--text-light);">У вас нет полученных подарков</div>';
                return;
            }
            
            myGiftsList.innerHTML = '';
            
            gifts.forEach(gift => {
                // Check if gift object has required properties to avoid undefined values
                if (!gift || !gift.icon || !gift.sender || !gift.timestamp) {
                    console.warn('Invalid gift object:', gift);
                    return;
                }
                
                const giftDate = new Date(gift.timestamp);
                const giftItem = document.createElement('div');
                giftItem.className = 'gift-item';
                
                // Safely access gift properties
                const giftIcon = gift.icon || '🎁';
                const giftSender = gift.sender || 'Неизвестный';
                
                giftItem.innerHTML = `
                    <div class="gift-icon">${giftIcon}</div>
                    <div class="gift-info">
                        <div class="gift-sender">${giftSender}</div>
                        <div class="gift-date">${giftDate.toLocaleDateString()} ${giftDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                    </div>
                    <div class="gift-actions">
                        <button class="gift-action-btn hide-gift-btn" data-gift-id="${gift.id || ''}" title="Скрыть">👁️</button>
                        <button class="gift-action-btn transfer-gift-btn" data-gift-id="${gift.id || ''}" title="Передарить">🔄</button>
                    </div>
                `;
                myGiftsList.appendChild(giftItem);
            });
            
            // Add event listeners for gift actions
            document.querySelectorAll('.hide-gift-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const giftId = e.target.getAttribute('data-gift-id');
                    if (giftId) hideGift(giftId);
                });
            });
            
            document.querySelectorAll('.transfer-gift-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const giftId = e.target.getAttribute('data-gift-id');
                    if (giftId) transferGift(giftId);
                });
            });
        }
        
        // Hide a gift (mark as hidden)
        async function hideGift(giftId) {
            try {
                // In a real implementation, we would update the gift's visibility status
                // For now, we'll just reload the gifts to show the change
                showNotification('Подарок скрыт');
                await loadMyGifts();
            } catch (error) {
                console.error('Error hiding gift:', error);
                showNotification('Ошибка при скрытии подарка');
            }
        }
        
        // Transfer a gift to another user
        async function transferGift(giftId) {
            try {
                // Prompt user for recipient
                const recipient = prompt('Введите имя пользователя, которому хотите передарить подарок:');
                
                if (!recipient) return;
                
                // Check if recipient exists
                const userRef = database.ref('users/' + encodeURIComponent(recipient));
                const snapshot = await userRef.once('value');
                
                if (!snapshot.exists()) {
                    showNotification('Пользователь не найден');
                    return;
                }
                
                // In a real implementation, we would move the gift to the recipient
                // For now, we'll just show a notification
                showNotification(`Подарок передан пользователю ${recipient}`);
                await loadMyGifts();
            } catch (error) {
                console.error('Error transferring gift:', error);
                showNotification('Ошибка при передаче подарка');
            }
        }
        
        async function handleLogout() {
            if (confirm('Вы уверены, что хотите выйти?')) {
                await updateUserStatus(false)
                    .finally(() => {
                        localStorage.removeItem('messenger_user');
                        currentUser = null;
                        currentUserData = null;
                        location.reload();
                    });
            }
        }
        
       // Функция для браузерных уведомлений
function showBrowserNotification(title, message) {
    // Проверяем, поддерживает ли браузер уведомления
    if (!("Notification" in window)) {
        console.log("[Notification] Browser does not support notifications");
        return;
    }
    
    // Проверяем, разрешены ли уведомления
    if (Notification.permission !== "granted") {
        console.log("[Notification] Permission not granted:", Notification.permission);
        return;
    }
    
    // Проверяем, включены ли уведомления в настройках приложения
    const notificationsEnabled = localStorage.getItem('notifications_enabled');
    if (notificationsEnabled !== 'true' && notificationsEnabled !== null) {
        console.log("[Notification] Notifications disabled in app settings");
        return;
    }
    
    // Если настройка не установлена, но разрешение есть - включаем по умолчанию
    if (notificationsEnabled === null) {
        localStorage.setItem('notifications_enabled', 'true');
    }
    
    console.log("[Notification] Showing notification:", title, message);
    
    const notificationOptions = {
        body: message,
        icon: "https://cdn.jsdelivr.net/npm/emoji-datasource-apple@7.0.2/img/apple/64/1f604.png",
        badge: "https://cdn.jsdelivr.net/npm/emoji-datasource-apple@7.0.2/img/apple/64/1f604.png",
        tag: 'twin-message-' + Date.now(),
        requireInteraction: false,
        silent: false,
        renotify: true
    };
    
    // Показываем уведомление
    try {
        const notification = new Notification(title, notificationOptions);
        console.log("[Notification] Notification created successfully");
        
        // Обработчик клика по уведомлению
        notification.onclick = function() {
            window.focus();
            notification.close();
        };
        
        // Обработчик ошибок
        notification.onerror = function(err) {
            console.log("[Notification] Error showing notification:", err);
        };
        
        // Автоматически закрываем уведомление через 8 секунд
        setTimeout(() => {
            notification.close();
        }, 8000);
        
        // Воспроизводим звук уведомления
        playNotificationSound();
    } catch (error) {
        console.log('[Notification] Error creating notification:', error);
    }
}

// Debug function to test notifications manually
function debugNotification() {
    console.log('[Debug] Testing notification system...');
    console.log('[Debug] Notification.permission:', Notification.permission);
    console.log('[Debug] notifications_enabled:', localStorage.getItem('notifications_enabled'));
    console.log('[Debug] document.hidden:', document.hidden);
    console.log('[Debug] currentUser:', currentUser);
    console.log('[Debug] currentChat:', currentChat);
    
    // Force show a test notification
    showBrowserNotification('Test Notification', 'This is a forced test notification');
}

// Make it available globally for debugging
window.debugNotification = debugNotification;

// Telegram-style toast notification system
let toastIdCounter = 0;
const activeToasts = new Map();

/**
 * Shows a Telegram-style toast notification
 * @param {Object} options - Notification options
 * @param {string} options.title - Notification title (sender name or chat name)
 * @param {string} options.message - Message text
 * @param {string} options.type - 'message', 'group', 'channel'
 * @param {string} options.chatId - Chat ID to open when clicked
 * @param {string} options.avatar - Avatar text/emoji or image URL
 * @param {number} options.duration - Duration in ms (default: 5000)
 */
function showToastNotification(options) {
    const {
        title,
        message,
        type = 'message',
        chatId = null,
        avatar = null,
        duration = 5000
    } = options;
    
    const container = document.getElementById('toast-container');
    if (!container) return;
    
    const toastId = `toast-${++toastIdCounter}`;
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = `toast-notification ${type}`;
    toast.id = toastId;
    
    // Determine avatar content
    let avatarContent = '';
    if (avatar && avatar.startsWith('http')) {
        avatarContent = `<img src="${avatar}" alt="">`;
    } else {
        const avatarText = avatar || title.charAt(0).toUpperCase();
        avatarContent = avatarText;
    }
    
    // Format current time
    const now = new Date();
    const timeStr = now.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
    
    // Build toast HTML
    toast.innerHTML = `
        <div class="toast-avatar">${avatarContent}</div>
        <div class="toast-content">
            <div class="toast-header">
                <span class="toast-title">${escapeHtml(title)}</span>
                <span class="toast-time">${timeStr}</span>
            </div>
            <div class="toast-message">${escapeHtml(message)}</div>
        </div>
        <button class="toast-close" onclick="closeToast('${toastId}')">&times;</button>
        <div class="toast-progress" style="width: 100%;"></div>
    `;
    
    // Add click handler to open chat
    if (chatId) {
        toast.addEventListener('click', (e) => {
            if (e.target.classList.contains('toast-close')) return;
            openChatFromToast(chatId, type);
            closeToast(toastId);
        });
    }
    
    // Add to container
    container.appendChild(toast);
    
    // Animate in
    requestAnimationFrame(() => {
        toast.classList.add('show');
    });
    
    // Progress bar animation
    const progressBar = toast.querySelector('.toast-progress');
    let progress = 100;
    const progressStep = 100 / (duration / 50); // Update every 50ms
    
    const progressInterval = setInterval(() => {
        progress -= progressStep;
        if (progressBar) {
            progressBar.style.width = `${Math.max(0, progress)}%`;
        }
        if (progress <= 0) {
            clearInterval(progressInterval);
        }
    }, 50);
    
    // Auto close
    const closeTimeout = setTimeout(() => {
        closeToast(toastId);
    }, duration);
    
    // Store toast data
    activeToasts.set(toastId, {
        element: toast,
        closeTimeout,
        progressInterval
    });
    
    // Play sound
    playNotificationSound();
    
    return toastId;
}

/**
 * Closes a specific toast notification
 * @param {string} toastId - ID of the toast to close
 */
function closeToast(toastId) {
    const toastData = activeToasts.get(toastId);
    if (!toastData) return;
    
    const { element, closeTimeout, progressInterval } = toastData;
    
    // Clear timers
    clearTimeout(closeTimeout);
    clearInterval(progressInterval);
    
    // Animate out
    element.classList.add('hiding');
    element.classList.remove('show');
    
    // Remove from DOM after animation
    setTimeout(() => {
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
        activeToasts.delete(toastId);
    }, 350);
}

/**
 * Opens a chat when toast is clicked
 * @param {string} chatId - Chat ID to open
 * @param {string} type - Chat type
 */
function openChatFromToast(chatId, type) {
    // Focus window
    window.focus();
    
    // Open the appropriate chat type
    if (type === 'group' || chatId.startsWith('group_')) {
        const group = groups.find(g => g.id === chatId);
        if (group) {
            openGroupChat(chatId, group.name);
        }
    } else if (type === 'channel' || chatId.startsWith('channel_')) {
        const channel = channels.find(c => c.id === chatId);
        if (channel) {
            openChannelChat(chatId, channel.name);
        }
    } else {
        // Personal chat - extract username from chatId
        const usernames = chatId.split('_');
        const otherUser = usernames.find(u => u !== currentUser);
        if (otherUser) {
            openChat(otherUser);
        }
    }
    
    // On mobile, close sidebar
    if (window.innerWidth <= 768) {
        closeSidebar();
    }
}

/**
 * Escapes HTML to prevent XSS
 * @param {string} text - Text to escape
 * @returns {string} Escaped text
 */
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Make toast functions globally available
window.showToastNotification = showToastNotification;
window.closeToast = closeToast;

// Глобальный аудио контекст для звуков уведомлений
let notificationAudioContext = null;

// Инициализация аудио контекста после пользовательского взаимодействия
function initAudioContext() {
    if (!notificationAudioContext) {
        notificationAudioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    // Возобновляем контекст если он приостановлен (требуется после пользовательского жеста)
    if (notificationAudioContext.state === 'suspended') {
        notificationAudioContext.resume();
    }
}

// Функция для воспроизведения звука уведомления
function playNotificationSound() {
    try {
        // Инициализируем контекст при первом вызове
        if (!notificationAudioContext) {
            notificationAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // Если контекст приостановлен, пытаемся возобновить
        // Это сработает только если был пользовательский жест
        if (notificationAudioContext.state === 'suspended') {
            notificationAudioContext.resume().catch(() => {
                // Игнорируем ошибку - звук просто не воспроизведется
            });
            return; // Не воспроизводим звук до получения пользовательского жеста
        }
        
        // Создаем простой звук
        const oscillator = notificationAudioContext.createOscillator();
        const gainNode = notificationAudioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(notificationAudioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(800, notificationAudioContext.currentTime);
        gainNode.gain.setValueAtTime(0.1, notificationAudioContext.currentTime);
        
        oscillator.start();
        oscillator.stop(notificationAudioContext.currentTime + 0.1);
    } catch (error) {
        // Игнорируем ошибки аудио
    }
}
        
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }
        
        // Функции для работы с каналами
        async function openCreateChannel() {
            channelNameInput.value = '';
            channelDescriptionInput.value = '';
            
            createChannelModal.classList.add('active');
            settingsMenu.classList.remove('active');
        }
        
        function closeCreateChannel() {
            createChannelModal.classList.remove('active');
        }
        
        async function createChannel() {
            const channelName = channelNameInput.value.trim();
            const channelDescription = channelDescriptionInput.value.trim();
            
            if (!channelName) {
                showNotification('Пожалуйста, введите название канала');
                return;
            }
            
            try {
                const channelId = 'channel_' + Date.now();
                
                await database.ref('channels/' + channelId).set({
                    name: channelName,
                    description: channelDescription,
                    creator: currentUser,
                    subscribers: [currentUser],
                    createdAt: Date.now()
                });
                
                showNotification('Канал создан успешно');
                closeCreateChannel();
                
                loadChannels();
                
                openChannelChat(channelId, channelName);
                
                subscribedChannels.push(channelId);
                await updateSubscribedChannels();
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function loadChannels() {
            try {
                const snapshot = await database.ref('channels').once('value');
                const channelsData = snapshot.val();
                channels = [];
                
                if (channelsData) {
                    Object.keys(channelsData).forEach(channelId => {
                        const channel = channelsData[channelId];
                        channels.push({
                            id: channelId,
                            name: channel.name,
                            description: channel.description,
                            creator: channel.creator,
                            subscribers: channel.subscribers || [],
                            createdAt: channel.createdAt,
                            icons: channel.icons || []
                        });
                    });
                }
                
                displayChannels();
            } catch (error) {
                console.error('Ошибка загрузки каналов:', error);
            }
        }
        
        function displayChannels() {
            searchResults.innerHTML = '';
            
            if (channels.length === 0) {
                searchResults.innerHTML = '<div class="user-item">Каналы не найдены</div>';
                return;
            }
            
            channels.forEach(channel => {
                const channelItem = document.createElement('div');
                channelItem.className = 'channel-item';
                
                const isSubscribed = subscribedChannels.includes(channel.id);
                const iconHtml = getChannelIconHtml(channel);
                
                channelItem.innerHTML = `
                    <div class="channel-icon">${iconHtml}</div>
                    <div class="channel-info">
                        <h3>${escapeHtml(channel.name)}</h3>
                        <p>${escapeHtml(channel.description || 'Нет описания')}</p>
                        <div class="channel-subscribers">
                            <span>👤 ${channel.subscribers ? channel.subscribers.length : 0}</span>
                        </div>
                    </div>
                    <button class="subscribe-btn ${isSubscribed ? 'subscribed' : ''}" data-channel-id="${channel.id}">
                        ${isSubscribed ? 'Отписаться' : 'Подписаться'}
                    </button>
                `;
                
                const subscribeBtn = channelItem.querySelector('.subscribe-btn');
                subscribeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleSubscribe(channel.id);
                });
                
                channelItem.addEventListener('click', () => {
                    if (isSubscribed) {
                        openChannelChat(channel.id, channel.name);
                    } else {
                        showNotification('Подпишитесь на канал, чтобы просматривать сообщения');
                    }
                });
                
                searchResults.appendChild(channelItem);
            });
        }
        
        async function toggleSubscribe(channelId) {
    try {
        const channel = channels.find(c => c.id === channelId);
        const isSubscribed = subscribedChannels.includes(channelId);
        
        if (isSubscribed) {
            subscribedChannels = subscribedChannels.filter(id => id !== channelId);
            showNotification('Вы отписались от канала');
        } else {
            subscribedChannels.push(channelId);
            showNotification('Вы подписались на канал');
            
            // Уведомление создателю канала о новом подписчике
            if (channel && channel.creator !== currentUser) {
                // Создаем уведомление в Firebase для создателя канала
                try {
                    const creatorNotificationsRef = database.ref('users/' + encodeURIComponent(channel.creator) + '/notifications');
                    await creatorNotificationsRef.push({
                        type: 'new_subscriber',
                        from: currentUser,
                        channelName: channel.name,
                        channelId: channelId,
                        timestamp: Date.now(),
                        read: false
                    });
                    
                    // Показываем браузерное уведомление создателю, если он онлайн
                    showBrowserNotification(
                        'Новый подписчик',
                        `${currentUser} подписался на ваш канал "${channel.name}"`
                    );
                } catch (error) {
                    console.error('Ошибка отправки уведомления создателю:', error);
                }
            }
        }
        
        await updateSubscribedChannels();
        
        if (channel) {
            if (isSubscribed) {
                channel.subscribers = channel.subscribers.filter(sub => sub !== currentUser);
            } else {
                if (!channel.subscribers) {
                    channel.subscribers = [];
                }
                channel.subscribers.push(currentUser);
            }
            
            await database.ref('channels/' + channelId).update({
                subscribers: channel.subscribers
            });
        }
        
        if (activeTab === 'channels') {
            loadChannels();
        } else if (activeTab === 'chats') {
            loadRecentChats();
        }
    } catch (error) {
        showNotification('Ошибка: ' + error.message);
    }
}

        
        async function updateSubscribedChannels() {
            try {
                await database.ref('users/' + encodeURIComponent(currentUser)).update({
                    subscribedChannels: subscribedChannels
                });
            } catch (error) {
                console.error('Ошибка обновления подписанных каналов:', error);
            }
        }
        
        async function loadSubscribedChannels() {
            try {
                const snapshot = await database.ref('users/' + encodeURIComponent(currentUser)).once('value');
                const userData = snapshot.val();
                if (userData && userData.subscribedChannels) {
                    subscribedChannels = userData.subscribedChannels;
                } else {
                    subscribedChannels = [];
                }
            } catch (error) {
                console.error('Ошибка загрузки подписанных каналов:', error);
                subscribedChannels = [];
            }
        }
        
        async function unsubscribeFromChannel(channelId) {
            subscribedChannels = subscribedChannels.filter(id => id !== channelId);
            await updateSubscribedChannels();
            
            const channel = channels.find(c => c.id === channelId);
            if (channel) {
                channel.subscribers = channel.subscribers.filter(sub => sub !== currentUser);
                
                await database.ref('channels/' + channelId).update({
                    subscribers: channel.subscribers
                });
            }
        }
        
        function openChannelChat(channelId, channelName) {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('active');
                mobileTitle.textContent = channelName;
            }
            
            if (currentChat && messageListeners[currentChat]) {
                clearInterval(messageListeners[currentChat]);
            }
            
            currentChat = channelId;
            currentChatType = 'channel';
            currentChannel = channels.find(c => c.id === channelId);
            currentGroup = null;
            emptyState.style.display = 'none';
            chatHeader.style.display = 'flex';
            chatMessages.style.display = 'block';
            
            if (currentChannel && currentChannel.creator === currentUser) {
                messageInputContainer.style.display = 'flex';
            } else {
                messageInputContainer.style.display = 'none';
            }
            
            // Get channel icon for header
            const iconHtml = currentChannel ? getChannelIconHtml(currentChannel) : '📢';
            
            chatUserEmoji.textContent = '';
            chatUserName.querySelector('span:last-child').textContent = channelName;
            
            // Check if icon is iframe or emoji
            if (currentChannel && currentChannel.icons && currentChannel.icons.length > 0) {
                chatAvatar.innerHTML = iconHtml;
            } else {
                chatAvatar.textContent = '📢';
            }
            
            blockUserBtn.style.display = 'none';
            groupSettingsBtn.style.display = 'none';
            
            // Скрываем кнопки профиля и подарков для каналов
            document.getElementById('view-profile-btn').style.display = 'none';
            document.getElementById('send-gift-btn').style.display = 'none';
            
            // Скрываем кнопку очистки истории AI
            const clearHistoryBtn = document.getElementById('clear-history-btn');
            if (clearHistoryBtn) clearHistoryBtn.style.display = 'none';
            
            // Скрываем кнопку звонка для каналов
            document.getElementById('audio-call-btn').style.display = 'none';
            
            if (currentChannel && currentChannel.creator === currentUser) {
                channelSettingsBtn.style.display = 'block';
            } else {
                channelSettingsBtn.style.display = 'none';
            }
            
            adjustMessageInput();
            
            loadMessages();
            
            messageListeners[channelId] = setInterval(() => {
                loadMessages();
            }, 3000);
        }
        
        async function openChannelSettings() {
            if (!currentChannel) return;
            
            editChannelNameInput.value = currentChannel.name;
            editChannelDescriptionInput.value = currentChannel.description || '';
            
            // Show/hide manage icons button based on whether user is the creator
            if (currentChannel.creator === currentUser) {
                manageChannelIconsBtn.style.display = 'block';
            } else {
                manageChannelIconsBtn.style.display = 'none';
            }
            
            channelSettingsModal.classList.add('active');
        }
        
        function closeChannelSettings() {
            channelSettingsModal.classList.remove('active');
        }
        
        async function saveChannelSettings() {
            if (!currentChannel) return;
            
            const newName = editChannelNameInput.value.trim();
            const newDescription = editChannelDescriptionInput.value.trim();
            
            if (!newName) {
                showNotification('Пожалуйста, введите название канала');
                return;
            }
            
            try {
                await database.ref('channels/' + currentChannel.id).update({
                    name: newName,
                    description: newDescription
                });
                
                currentChannel.name = newName;
                currentChannel.description = newDescription;
                
                chatUserName.querySelector('span:last-child').textContent = newName;
                
                showNotification('Настройки канала сохранены');
                closeChannelSettings();
                
                loadChannels();
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function unsubscribeChannel() {
            if (!currentChannel) return;
            
            if (confirm('Вы уверены, что хотите отписаться от этого канала?')) {
                try {
                    await unsubscribeFromChannel(currentChannel.id);
                    
                    showNotification('Вы отписались от канала');
                    closeChannelSettings();
                    closeChat();
                    
                    loadChannels();
                } catch (error) {
                    showNotification('Ошибка: ' + error.message);
                }
            }
        }
        
        // Functions for channel icon management
        async function openChannelIconsModal() {
            if (!currentChannel || currentChannel.creator !== currentUser) {
                showNotification('Только создатель канала может управлять иконками');
                return;
            }
            
            closeChannelSettings();
            await loadChannelIcons();
            channelIconsModal.classList.add('active');
        }
        
        function closeChannelIconsModal() {
            channelIconsModal.classList.remove('active');
            channelIconUrlInput.value = '';
            updateChannelIconPreview();
        }
        
        function updateChannelIconPreview() {
            const url = channelIconUrlInput.value.trim();
            if (url) {
                channelIconPreview.innerHTML = `<iframe src="${escapeHtml(url)}" sandbox="allow-scripts"></iframe>`;
            } else {
                channelIconPreview.innerHTML = '<span>📢</span>';
            }
        }
        
        async function loadChannelIcons() {
            if (!currentChannel) return;
            
            try {
                const snapshot = await database.ref('channels/' + currentChannel.id + '/icons').once('value');
                const icons = snapshot.val();
                
                displayChannelIcons(icons || []);
            } catch (error) {
                console.error('Ошибка загрузки иконок канала:', error);
                channelIconsList.innerHTML = '<div style="text-align: center; color: var(--text-light); padding: 10px;">Ошибка загрузки иконок</div>';
            }
        }
        
        function displayChannelIcons(icons) {
            channelIconsList.innerHTML = '';
            
            if (!icons || icons.length === 0) {
                channelIconsList.innerHTML = '<div style="text-align: center; color: var(--text-light); padding: 10px;">Нет добавленных иконок</div>';
                return;
            }
            
            icons.forEach((iconUrl, index) => {
                const iconItem = document.createElement('div');
                iconItem.className = 'channel-icon-item';
                iconItem.innerHTML = `
                    <div class="channel-icon-display">
                        <iframe src="${escapeHtml(iconUrl)}" sandbox="allow-scripts"></iframe>
                    </div>
                    <div class="channel-icon-url">${escapeHtml(iconUrl)}</div>
                    <button class="delete-icon-btn" data-icon-index="${index}">Удалить</button>
                `;
                
                const deleteBtn = iconItem.querySelector('.delete-icon-btn');
                deleteBtn.addEventListener('click', () => deleteChannelIcon(index));
                
                channelIconsList.appendChild(iconItem);
            });
        }
        
        async function addChannelIcon() {
            if (!currentChannel || currentChannel.creator !== currentUser) {
                showNotification('Только создатель канала может добавлять иконки');
                return;
            }
            
            const iconUrl = channelIconUrlInput.value.trim();
            
            if (!iconUrl) {
                showNotification('Пожалуйста, введите URL иконки');
                return;
            }
            
            // Basic URL validation
            if (!iconUrl.startsWith('http://') && !iconUrl.startsWith('https://')) {
                showNotification('URL должен начинаться с http:// или https://');
                return;
            }
            
            try {
                const snapshot = await database.ref('channels/' + currentChannel.id + '/icons').once('value');
                const currentIcons = snapshot.val() || [];
                
                // Check if icon already exists
                if (currentIcons.includes(iconUrl)) {
                    showNotification('Эта иконка уже добавлена');
                    return;
                }
                
                currentIcons.push(iconUrl);
                
                await database.ref('channels/' + currentChannel.id).update({
                    icons: currentIcons
                });
                
                currentChannel.icons = currentIcons;
                
                showNotification('Иконка добавлена успешно');
                channelIconUrlInput.value = '';
                updateChannelIconPreview();
                await loadChannelIcons();
                
                // Refresh channel display
                loadChannels();
                if (activeTab === 'chats') {
                    loadRecentChats();
                }
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function deleteChannelIcon(index) {
            if (!currentChannel || currentChannel.creator !== currentUser) {
                showNotification('Только создатель канала может удалять иконки');
                return;
            }
            
            if (!confirm('Вы уверены, что хотите удалить эту иконку?')) {
                return;
            }
            
            try {
                const snapshot = await database.ref('channels/' + currentChannel.id + '/icons').once('value');
                const currentIcons = snapshot.val() || [];
                
                if (index < 0 || index >= currentIcons.length) {
                    showNotification('Иконка не найдена');
                    return;
                }
                
                currentIcons.splice(index, 1);
                
                await database.ref('channels/' + currentChannel.id).update({
                    icons: currentIcons
                });
                
                currentChannel.icons = currentIcons;
                
                showNotification('Иконка удалена');
                await loadChannelIcons();
                
                // Refresh channel display
                loadChannels();
                if (activeTab === 'chats') {
                    loadRecentChats();
                }
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        // Helper function to get channel icon HTML
        function getChannelIconHtml(channel) {
            if (channel.icons && channel.icons.length > 0) {
                // Use the first icon (most recent)
                const iconUrl = channel.icons[channel.icons.length - 1];
                return `<iframe src="${escapeHtml(iconUrl)}" sandbox="allow-scripts"></iframe>`;
            }
            // Default icon
            return '📢';
        }
        
        async function loadBlockedUsers() {
            try {
                const snapshot = await database.ref('users/' + encodeURIComponent(currentUser)).once('value');
                const userData = snapshot.val();
                if (userData && userData.blockedUsers) {
                    blockedUsers = userData.blockedUsers;
                } else {
                    blockedUsers = [];
                }
            } catch (error) {
                console.error('Ошибка загрузки заблокированных пользователей:', error);
                blockedUsers = [];
            }
        }
        
        function displayBlockedUsers() {
            blockedList.innerHTML = '';
            
            if (blockedUsers.length === 0) {
                blockedList.innerHTML = '<div>Нет заблокированных пользователей</div>';
                return;
            }
            
            blockedUsers.forEach(username => {
                const blockedItem = document.createElement('div');
                blockedItem.className = 'blocked-item';
                blockedItem.innerHTML = `
                    <span>${escapeHtml(username)}</span>
                    <button class="unblock-btn" data-username="${username}">Разблокировать</button>
                `;
                
                blockedList.appendChild(blockedItem);
            });
            
            document.querySelectorAll('.unblock-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const username = btn.dataset.username;
                    unblockUser(username);
                });
            });
        }
        
        async function unblockUser(username) {
            try {
                blockedUsers = blockedUsers.filter(u => u !== username);
                
                await database.ref('users/' + encodeURIComponent(currentUser)).update({
                    blockedUsers: blockedUsers
                });
                
                displayBlockedUsers();
                showNotification(`Пользователь ${username} разблокирован`);
                
                if (activeTab === 'users') {
                    loadUsers();
                }
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function toggleBlockUser() {
            if (!currentChat || currentChatType !== 'user') {
                showNotification('Нельзя заблокировать группу или канал');
                return;
            }
            
            const isBlocked = blockedUsers.includes(currentChat);
            
            if (isBlocked) {
                await unblockUser(currentChat);
                blockUserBtn.innerHTML = '🚫';
                blockUserBtn.title = 'Заблокировать пользователя';
            } else {
                if (confirm(`Вы уверены, что хотите заблокировать пользователя ${currentChat}?`)) {
                    try {
                        blockedUsers.push(currentChat);
                        
                        await database.ref('users/' + encodeURIComponent(currentUser)).update({
                            blockedUsers: blockedUsers
                        });
                        
                        showNotification(`Пользователь ${currentChat} заблокирован`);
                        blockUserBtn.innerHTML = '🔓';
                        blockUserBtn.title = 'Разблокировать пользователя';
                        
                        if (activeTab === 'users') {
                            loadUsers();
                        }
                    } catch (error) {
                        showNotification('Ошибка: ' + error.message);
                    }
                }
            }
        }
        
        async function openCreateGroup() {
            groupNameInput.value = '';
            participantsList.innerHTML = '';
            
            try {
                // Показываем только пользователей из recentChats
                if (!currentUserData || !currentUserData.recentChats || currentUserData.recentChats.length === 0) {
                    participantsList.innerHTML = '<div style="padding: 10px; color: var(--text-light);">Сначала добавьте пользователей через поиск во вкладке "Пользователи"</div>';
                    createGroupModal.classList.add('active');
                    settingsMenu.classList.remove('active');
                    return;
                }
                
                for (const chat of currentUserData.recentChats) {
                    if (chat.username && chat.username !== currentUser) {
                        const participantItem = document.createElement('div');
                        participantItem.className = 'participant-item';
                        participantItem.innerHTML = `
                            <input type="checkbox" class="participant-checkbox" id="user-${chat.username}" value="${chat.username}">
                            <label for="user-${chat.username}">${escapeHtml(chat.name || chat.username)} ${chat.emoji || '😊'}</label>
                        `;
                        
                        participantsList.appendChild(participantItem);
                    }
                }
                
                createGroupModal.classList.add('active');
                settingsMenu.classList.remove('active');
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        function closeCreateGroup() {
            createGroupModal.classList.remove('active');
        }
        
        async function createGroup() {
            const groupName = groupNameInput.value.trim();
            if (!groupName) {
                showNotification('Пожалуйста, введите название группы');
                return;
            }
            
            const checkboxes = document.querySelectorAll('.participant-checkbox:checked');
            const participants = Array.from(checkboxes).map(cb => cb.value);
            
            if (participants.length < 1) {
                showNotification('Выберите хотя бы одного участника');
                return;
            }
            
            participants.push(currentUser);
            
            try {
                const groupId = 'group_' + Date.now();
                
                await database.ref('groups/' + groupId).set({
                    name: groupName,
                    admin: currentUser,
                    participants: participants,
                    createdAt: Date.now()
                });
                
                showNotification('Группа создана успешно');
                closeCreateGroup();
                
                loadGroups();
                
                openGroupChat(groupId, groupName);
                
                participants.forEach(async participant => {
                    if (participant !== currentUser) {
                        try {
                            await database.ref('users/' + encodeURIComponent(participant) + '/notifications').push({
                                type: 'group_invite',
                                groupId: groupId,
                                groupName: groupName,
                                from: currentUser,
                                timestamp: Date.now(),
                                read: false
                            });
                        } catch (error) {
                            console.error(`Ошибка отправки уведомления пользователю ${participant}:`, error);
                        }
                    }
                });
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function loadGroups() {
            try {
                const snapshot = await database.ref('groups').once('value');
                const groupsData = snapshot.val();
                groups = [];
                
                if (groupsData) {
                    Object.keys(groupsData).forEach(groupId => {
                        const group = groupsData[groupId];
                        if (group.participants && group.participants.includes(currentUser)) {
                            groups.push({
                                id: groupId,
                                name: group.name,
                                admin: group.admin,
                                participants: group.participants,
                                createdAt: group.createdAt
                            });
                        }
                    });
                }
                
                if (activeTab === 'chats') {
                    loadRecentChats();
                }
            } catch (error) {
                console.error('Ошибка загрузки групп:', error);
            }
        }
        
        function openGroupChat(groupId, groupName) {
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('active');
                mobileTitle.textContent = groupName;
            }
            
            if (currentChat && messageListeners[currentChat]) {
                clearInterval(messageListeners[currentChat]);
            }
            
            currentChat = groupId;
            currentChatType = 'group';
            currentGroup = groups.find(g => g.id === groupId);
            emptyState.style.display = 'none';
            chatHeader.style.display = 'flex';
            chatMessages.style.display = 'block';
            messageInputContainer.style.display = 'flex';
            
            chatUserEmoji.textContent = '👥';
            chatUserName.querySelector('span:last-child').textContent = groupName;
            chatAvatar.textContent = '👥';
            
            blockUserBtn.style.display = 'none';
            
            // Скрываем кнопки профиля и подарков для групп
            document.getElementById('view-profile-btn').style.display = 'none';
            document.getElementById('send-gift-btn').style.display = 'none';
            
            // Скрываем кнопку очистки истории AI
            const clearHistoryBtn = document.getElementById('clear-history-btn');
            if (clearHistoryBtn) clearHistoryBtn.style.display = 'none';
            
            // Скрываем кнопку звонка для групп
            document.getElementById('audio-call-btn').style.display = 'none';
            
            if (currentGroup && currentGroup.admin === currentUser) {
                groupSettingsBtn.style.display = 'block';
            } else {
                groupSettingsBtn.style.display = 'none';
            }
            
            channelSettingsBtn.style.display = 'none';
            
            adjustMessageInput();
            
            loadMessages();
            
            messageListeners[groupId] = setInterval(() => {
                loadMessages();
            }, 3000);
        }
        
        async function openGroupSettings() {
            if (!currentGroup) return;
            
            editGroupNameInput.value = currentGroup.name;
            editParticipantsList.innerHTML = '';
            
            try {
                // Получаем данные участников из Firebase
                for (const participant of currentGroup.participants) {
                    if (participant !== currentUser) {
                        const snapshot = await database.ref('users/' + encodeURIComponent(participant)).once('value');
                        const user = snapshot.val();
                        
                        const participantItem = document.createElement('div');
                        participantItem.className = 'participant-item';
                        participantItem.innerHTML = `
                            <span>${escapeHtml(user ? (user.name || user.username) : participant)} ${user ? (user.emoji || '😊') : ''}</span>
                            ${currentGroup.admin === currentUser ? `<button class="remove-participant-btn" data-username="${participant}">Удалить</button>` : ''}
                        `;
                        
                        editParticipantsList.appendChild(participantItem);
                    }
                }
                
                document.querySelectorAll('.remove-participant-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const username = btn.dataset.username;
                        removeParticipant(username);
                    });
                });
                
                groupSettingsModal.classList.add('active');
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function removeParticipant(username) {
            if (!currentGroup || currentGroup.admin !== currentUser) return;
            
            if (confirm(`Вы уверены, что хотите удалить ${username} из группы?`)) {
                try {
                    const updatedParticipants = currentGroup.participants.filter(p => p !== username);
                    
                    await database.ref('groups/' + currentGroup.id).update({
                        participants: updatedParticipants
                    });
                    
                    currentGroup.participants = updatedParticipants;
                    
                    showNotification(`Пользователь ${username} удален из группы`);
                    
                    openGroupSettings();
                    
                    try {
                        await database.ref('users/' + encodeURIComponent(username) + '/notifications').push({
                            type: 'group_remove',
                            groupId: currentGroup.id,
                            groupName: currentGroup.name,
                            from: currentUser,
                            timestamp: Date.now(),
                            read: false
                        });
                    } catch (error) {
                        console.error(`Ошибка отправки уведомления пользователю ${username}:`, error);
                    }
                } catch (error) {
                    showNotification('Ошибка: ' + error.message);
                }
            }
        }
        
        function closeGroupSettings() {
            groupSettingsModal.classList.remove('active');
        }
        
        async function saveGroupSettings() {
            if (!currentGroup) return;
            
            const newName = editGroupNameInput.value.trim();
            if (!newName) {
                showNotification('Пожалуйста, введите название группы');
                return;
            }
            
            try {
                await database.ref('groups/' + currentGroup.id).update({
                    name: newName
                });
                
                currentGroup.name = newName;
                
                chatUserName.querySelector('span:last-child').textContent = newName;
                
                showNotification('Настройки группы сохранены');
                closeGroupSettings();
                
                loadGroups();
            } catch (error) {
                showNotification('Ошибка: ' + error.message);
            }
        }
        
        async function leaveGroup() {
            if (!currentGroup) return;
            
            if (confirm('Вы уверены, что хотите покинуть эту группу?')) {
                try {
                    const updatedParticipants = currentGroup.participants.filter(p => p !== currentUser);
                    
                    await database.ref('groups/' + currentGroup.id).update({
                        participants: updatedParticipants
                    });
                    
                    showNotification('Вы покинули группу');
                    closeGroupSettings();
                    closeChat();
                    
                    loadGroups();
                } catch (error) {
                    showNotification('Ошибка: ' + error.message);
                }
            }
        }
        
        async function deleteChat() {
            if (!currentChat) return;
            
            let confirmMessage = '';
            let group = null;
            let channel = null;
            
            if (currentChatType === 'group') {
                group = currentGroup || groups.find(g => g.id === currentChat);
                if (group && group.admin === currentUser) {
                    confirmMessage = 'Вы уверены, что хотите удалить эту группу? Это действие необратимо.';
                } else {
                    confirmMessage = 'Вы уверены, что хотите покинуть эту группу?';
                }
            } else if (currentChatType === 'channel') {
                channel = currentChannel || channels.find(c => c.id === currentChat);
                if (channel && channel.creator === currentUser) {
                    confirmMessage = 'Вы уверены, что хотите удалить этот канал? Это действие необратимо.';
                } else {
                    confirmMessage = 'Вы уверены, что хотите отписаться от этого канала?';
                }
            } else {
                confirmMessage = 'Вы уверены, что хотите удалить этот чат? Все сообщения будут удалены.';
            }
            
            if (confirm(confirmMessage)) {
                try {
                    if (currentChatType === 'group') {
                        if (!group && currentChat) {
                            const groupSnapshot = await database.ref('groups/' + currentChat).once('value');
                            group = groupSnapshot.val();
                        }
                        
                        if (group && group.admin === currentUser) {
                            await database.ref('groups/' + currentChat).remove();
                            await database.ref('messages/' + currentChat).remove();
                            showNotification('Группа удалена');
                        } else if (group && group.participants) {
                            const updatedParticipants = group.participants.filter(p => p !== currentUser);
                            await database.ref('groups/' + currentChat).update({
                                participants: updatedParticipants
                            });
                            showNotification('Вы покинули группу');
                        } else {
                            showNotification('Группа не найдена');
                        }
                        
                        await loadGroups();
                    } else if (currentChatType === 'channel') {
                        if (!channel && currentChat) {
                            const channelSnapshot = await database.ref('channels/' + currentChat).once('value');
                            channel = channelSnapshot.val();
                        }
                        
                        if (channel && channel.creator === currentUser) {
                            await database.ref('channels/' + currentChat).remove();
                            await database.ref('messages/' + currentChat).remove();
                            showNotification('Канал удален');
                        } else {
                            await unsubscribeFromChannel(currentChat);
                            showNotification('Вы отписались от канала');
                        }
                        
                        await loadChannels();
                    } else {
                        const chatId = getChatId(currentUser, currentChat);
                        await database.ref('messages/' + chatId).remove();
                        
                        // Удаляем пользователя из recentChats
                        const userRef = database.ref('users/' + encodeURIComponent(currentUser));
                        const snapshot = await userRef.once('value');
                        const userData = snapshot.val();
                        
                        if (userData && userData.recentChats) {
                            const updatedRecentChats = userData.recentChats.filter(chat => chat.username !== currentChat);
                            await userRef.update({ recentChats: updatedRecentChats });
                            currentUserData.recentChats = updatedRecentChats;
                        }
                        
                        showNotification('Чат удален');
                    }
                    
                    closeChat();
                    
                    if (activeTab === 'chats') {
                        await loadRecentChats();
                    }
                } catch (error) {
                    showNotification('Ошибка: ' + error.message);
                }
            }
        }
        
        // Переменные для хранения данных текущего пользователя
        // Используем глобальную currentUserData, объявленную выше
        
        // Показать модальное окно входа/регистрации
        async function requestUsername() {
            const modal = document.createElement('div');
            modal.id = 'auth-modal';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.right = '0';
            modal.style.bottom = '0';
            modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '1000';
            
            const modalContent = document.createElement('div');
            modalContent.style.backgroundColor = 'white';
            modalContent.style.padding = '20px';
            modalContent.style.borderRadius = '10px';
            modalContent.style.width = '90%';
            modalContent.style.maxWidth = '400px';
            modalContent.style.maxHeight = '90vh';
            modalContent.style.overflowY = 'auto';
            
            modalContent.innerHTML = `
                <h2 style="margin-bottom: 15px; text-align: center;">Вход / Регистрация</h2>
                <div id="auth-tabs" style="display: flex; margin-bottom: 15px; border-bottom: 1px solid #ddd;">
                    <button id="login-tab" style="flex: 1; padding: 10px; border: none; background: #6c5ce7; color: white; cursor: pointer;">Вход</button>
                    <button id="register-tab" style="flex: 1; padding: 10px; border: none; background: #f0f0f0; color: #333; cursor: pointer;">Регистрация</button>
                </div>
                <div id="login-form">
                    <input type="text" id="login-username" 
                           style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; font-size: 16px;"
                           placeholder="Юзернейм" autocomplete="off">
                    <input type="password" id="login-password" 
                           style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px; font-size: 16px;"
                           placeholder="Пароль">
                    <button id="submit-login" 
                            style="width: 100%; padding: 12px; background: #6c5ce7; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Войти
                    </button>
                </div>
                <div id="register-form" style="display: none;">
                    <input type="text" id="reg-name" 
                           style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; font-size: 16px;"
                           placeholder="Имя" autocomplete="off">
                    <input type="text" id="reg-username" 
                           style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; font-size: 16px;"
                           placeholder="Юзернейм (уникальный)" autocomplete="off">
                    <input type="password" id="reg-password" 
                           style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px; font-size: 16px;"
                           placeholder="Пароль">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;">Выберите статус:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <span class="emoji-option" data-emoji="😊" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">😊</span>
                            <span class="emoji-option" data-emoji="😎" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">😎</span>
                            <span class="emoji-option" data-emoji="🤔" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">🤔</span>
                            <span class="emoji-option" data-emoji="😴" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">😴</span>
                            <span class="emoji-option" data-emoji="😢" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">😢</span>
                            <span class="emoji-option" data-emoji="😡" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">😡</span>
                            <span class="emoji-option" data-emoji="🥳" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">🥳</span>
                            <span class="emoji-option" data-emoji="😍" style="font-size: 1.5rem; cursor: pointer; padding: 5px; border-radius: 5px;">😍</span>
                        </div>
                    </div>
                    <button id="submit-register" 
                            style="width: 100%; padding: 12px; background: #2ecc71; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Зарегистрироваться
                    </button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            const loginTab = document.getElementById('login-tab');
            const registerTab = document.getElementById('register-tab');
            const loginForm = document.getElementById('login-form');
            const registerForm = document.getElementById('register-form');
            
            loginTab.addEventListener('click', () => {
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
                loginTab.style.background = '#6c5ce7';
                loginTab.style.color = 'white';
                registerTab.style.background = '#f0f0f0';
                registerTab.style.color = '#333';
            });
            
            registerTab.addEventListener('click', () => {
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
                registerTab.style.background = '#6c5ce7';
                registerTab.style.color = 'white';
                loginTab.style.background = '#f0f0f0';
                loginTab.style.color = '#333';
            });
            
            // Регистрация
            const regName = document.getElementById('reg-name');
            const regUsername = document.getElementById('reg-username');
            const regPassword = document.getElementById('reg-password');
            const submitRegister = document.getElementById('submit-register');
            const emojiOptions = registerForm.querySelectorAll('.emoji-option');
            
            // Проверяем, что emoji-опции найдены
            if (emojiOptions.length > 0) {
                emojiOptions[0].classList.add('selected');
                userEmoji = emojiOptions[0].dataset.emoji;
            } else {
                userEmoji = '😊'; // Значение по умолчанию
            }
            
            emojiOptions.forEach(opt => {
                opt.addEventListener('click', () => {
                    emojiOptions.forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    userEmoji = opt.dataset.emoji;
                });
            });
            
            submitRegister.addEventListener('click', async () => {
                const name = regName.value.trim();
                const username = regUsername.value.trim().toLowerCase();
                const password = regPassword.value.trim();
                
                if (!name || !username || !password) {
                    showNotification('Пожалуйста, заполните все поля');
                    return;
                }
                
                if (username.length < 3) {
                    showNotification('Юзернейм должен быть не менее 3 символов');
                    return;
                }
                
                if (password.length < 4) {
                    showNotification('Пароль должен быть не менее 4 символов');
                    return;
                }
                
                try {
                    const userRef = database.ref('users/' + encodeURIComponent(username));
                    const snapshot = await userRef.once('value');
                    
                    if (snapshot.exists()) {
                        showNotification('Этот юзернейм уже занят');
                        return;
                    }
                    
                    currentUser = username;
                    currentUserData = {
                        name: name,
                        username: username,
                        password: password,
                        emoji: userEmoji,
                        online: true,
                        lastSeen: Date.now(),
                        blockedUsers: [],
                        subscribedChannels: [],
                        recentChats: [],
                        gifts: { 'heart': 2 }
                    };
                    
                    await userRef.set(currentUserData);
                    localStorage.setItem('messenger_user', JSON.stringify({username: username, password: password}));
                    
                    // Обновляем UI с проверкой существования элементов
                    if (currentUserEl) {
                        const nameSpan = currentUserEl.querySelector('span:last-child');
                        if (nameSpan) nameSpan.textContent = name;
                    }
                    if (userEmojiEl) {
                        userEmojiEl.textContent = userEmoji;
                    }
                    
                    // Update post field avatar as well
                    const postUserAvatar = document.getElementById('post-user-avatar');
                    if (postUserAvatar) {
                        postUserAvatar.textContent = userEmoji.charAt(0).toUpperCase();
                    }
                    
                    await updateUserStatus(true);
                    
                    loadRecentChats();
                    loadGroups();
                    loadChannels();
                    
                    document.body.removeChild(modal);
                    
                    subscribeToPushNotifications();
                    startBackgroundChecks();
                    trackUserStatus();
                    
                    showNotification('Регистрация успешна!');
                } catch (error) {
                    showNotification('Ошибка: ' + error.message);
                }
            });
            
            // Вход
            const loginUsername = document.getElementById('login-username');
            const loginPassword = document.getElementById('login-password');
            const submitLogin = document.getElementById('submit-login');
            
            submitLogin.addEventListener('click', async () => {
                const username = loginUsername.value.trim().toLowerCase();
                const password = loginPassword.value.trim();
                
                if (!username || !password) {
                    showNotification('Пожалуйста, введите юзернейм и пароль');
                    return;
                }
                
                try {
                    const userRef = database.ref('users/' + encodeURIComponent(username));
                    const snapshot = await userRef.once('value');
                    
                    if (!snapshot.exists()) {
                        showNotification('Пользователь не найден');
                        return;
                    }
                    
                    const userData = snapshot.val();
                    
                    if (userData.password !== password) {
                        showNotification('Неверный пароль');
                        return;
                    }
                    
                    currentUser = username;
                    currentUserData = userData;
                    userEmoji = userData.emoji || '😊';
                    blockedUsers = userData.blockedUsers || [];
                    subscribedChannels = userData.subscribedChannels || [];
                    
                    // Initialize gifts if not present
                    if (!userData.gifts) {
                        currentUserData.gifts = { 'heart': 2 };
                        await database.ref('users/' + encodeURIComponent(currentUser)).update({
                            gifts: { 'heart': 2 }
                        });
                    }
                    
                    localStorage.setItem('messenger_user', JSON.stringify({username: username, password: password}));
                    
                    // Обновляем UI с проверкой существования элементов
                    if (currentUserEl) {
                        const nameSpan = currentUserEl.querySelector('span:last-child');
                        if (nameSpan) nameSpan.textContent = userData.name || username;
                    }
                    if (userEmojiEl) {
                        userEmojiEl.textContent = userEmoji;
                    }
                    
                    // Update post field avatar as well
                    const postUserAvatar = document.getElementById('post-user-avatar');
                    if (postUserAvatar) {
                        postUserAvatar.textContent = userEmoji.charAt(0).toUpperCase();
                    }
                    
                    await updateUserStatus(true);
                    
                    loadRecentChats();
                    loadGroups();
                    loadChannels();
                    
                    document.body.removeChild(modal);
                    
                    subscribeToPushNotifications();
                    startBackgroundChecks();
                    trackUserStatus();
                    initCallListeners();
                    
                    showNotification('Вход выполнен успешно!');
                } catch (error) {
                    showNotification('Ошибка: ' + error.message);
                }
            });
            
            // Enter key support
            loginPassword.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') submitLogin.click();
            });
            regPassword.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') submitRegister.click();
            });
            
            loginUsername.focus();
        }
        
        // Обработка закрытия вкладки/приложения
        window.addEventListener('beforeunload', () => {
            if (currentUser) {
                database.ref('users/' + encodeURIComponent(currentUser)).update({
                    online: false,
                    lastSeen: Date.now()
                });
            }
            // Завершаем звонок при закрытии
            if (currentCall) {
                endCall();
            }
        });
        
        // ==================== AUDIO CALL SYSTEM ====================
        
        let localStream = null;
        let remoteAudio = null;
        let peerConnection = null;
        let currentCall = null;
        let isCallInitiator = false;
        let isAudioMuted = false;
        let currentCallType = 'audio';
        
        const iceServers = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };
        
        const callModal = document.getElementById('call-modal');
        const incomingCallModal = document.getElementById('incoming-call-modal');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const callName = document.getElementById('call-name');
        const callStatus = document.getElementById('call-status');
        const callAvatar = document.getElementById('call-avatar');
        const incomingCallName = document.getElementById('incoming-call-name');
        const incomingCallAvatar = document.getElementById('incoming-call-avatar');
        const callVideos = document.getElementById('call-videos');
        const callAudioOnly = document.getElementById('call-audio-only');
        
        function initCallListeners() {
            if (!currentUser) return;
            
            database.ref('calls/' + encodeURIComponent(currentUser)).on('value', async (snapshot) => {
                const data = snapshot.val();
                if (!data) return;
                
                // Входящий звонок
                if (data.status === 'calling' && data.to === currentUser && !currentCall) {
                    currentCall = data;
                    isCallInitiator = false;
                    incomingCallName.textContent = data.from;
                    incomingCallAvatar.textContent = data.from.charAt(0).toUpperCase();
                    incomingCallModal.classList.add('active');
                    playRingtone();
                }
                
                // Отменен
                if (data.status === 'cancelled' && currentCall) {
                    endCall();
                    showNotification('Звонок отменен');
                }
                
                // Отклонен
                if (data.status === 'declined' && isCallInitiator) {
                    endCall();
                    showNotification('Звонок отклонен');
                }
                
                // Принят - начинаем WebRTC
                if (data.status === 'accepted' && isCallInitiator) {
                    callStatus.textContent = 'Соединение...';
                    await createOffer();
                }
                
                // Получили offer
                if (data.offer && !isCallInitiator && peerConnection) {
                    await handleOffer(data.offer);
                }
                
                // Получили answer
                if (data.answer && isCallInitiator && peerConnection) {
                    await handleAnswer(data.answer);
                }
                
                // Получили ICE
                if (data.iceCandidate && peerConnection) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.iceCandidate));
                    } catch (e) {}
                }
            });
        }
        
        async function startAudioCall() {
            if (!currentChat || currentChatType !== 'user') {
                showNotification('Звонки только в личных чатах');
                return;
            }
            
            try {
                currentCallType = 'audio';
                isCallInitiator = true;
                currentCall = { from: currentUser, to: currentChat, type: 'audio', status: 'calling' };
                
                showCallUI(currentChat, 'audio');
                callStatus.textContent = 'Вызов...';
                
                // Инициализируем WebRTC сразу
                await initPeerConnection();
                
                // Получаем микрофон
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
                
                // Создаем запись о звонке
                await database.ref('calls/' + encodeURIComponent(currentChat)).set({
                    from: currentUser,
                    to: currentChat,
                    type: 'audio',
                    status: 'calling',
                    timestamp: Date.now()
                });
                
                // Таймаут 30 сек
                setTimeout(() => {
                    if (currentCall && currentCall.status === 'calling') {
                        endCall();
                        showNotification('Нет ответа');
                    }
                }, 30000);
                
            } catch (err) {
                console.error('Call error:', err);
                showNotification('Ошибка: ' + err.message);
                endCall();
            }
        }
        
        async function initPeerConnection() {
            peerConnection = new RTCPeerConnection(iceServers);
            
            // Создаем аудио элемент для remote
            if (!remoteAudio) {
                remoteAudio = new Audio();
                remoteAudio.autoplay = true;
            }
            
            peerConnection.ontrack = (e) => {
                console.log('Remote audio received');
                remoteAudio.srcObject = e.streams[0];
                callStatus.textContent = 'Разговор';
            };
            
            peerConnection.onicecandidate = (e) => {
                if (e.candidate && currentCall) {
                    const target = isCallInitiator ? currentCall.to : currentCall.from;
                    database.ref('calls/' + encodeURIComponent(target) + '/iceCandidate').set({
                        candidate: e.candidate.candidate,
                        sdpMid: e.candidate.sdpMid,
                        sdpMLineIndex: e.candidate.sdpMLineIndex
                    });
                }
            };
            
            peerConnection.onconnectionstatechange = () => {
                console.log('State:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    callStatus.textContent = 'Разговор';
                }
                if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                    endCall();
                }
            };
        }
        
        async function createOffer() {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                await database.ref('calls/' + encodeURIComponent(currentCall.to)).update({ offer: offer });
            } catch (err) {
                console.error('Offer error:', err);
            }
        }
        
        async function handleOffer(offer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                await database.ref('calls/' + encodeURIComponent(currentUser)).update({ answer: answer });
            } catch (err) {
                console.error('Handle offer error:', err);
            }
        }
        
        async function handleAnswer(answer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            } catch (err) {
                console.error('Handle answer error:', err);
            }
        }
        
        async function acceptCall() {
            stopRingtone();
            incomingCallModal.classList.remove('active');
            
            showCallUI(currentCall.from, 'audio');
            callStatus.textContent = 'Соединение...';
            
            try {
                // Инициализируем WebRTC и получаем микрофон ДО обновления статуса
                await initPeerConnection();
                
                // Получаем микрофон
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
                
                // Проверяем, есть ли уже offer от звонящего
                const callSnapshot = await database.ref('calls/' + encodeURIComponent(currentUser)).once('value');
                const callData = callSnapshot.val();
                if (callData && callData.offer) {
                    // Если offer уже есть, сразу обрабатываем его
                    await handleOffer(callData.offer);
                }
                
                // Теперь, когда мы готовы принять offer, обновляем статус
                await database.ref('calls/' + encodeURIComponent(currentUser)).update({ status: 'accepted' });
                
            } catch (err) {
                console.error('Accept error:', err);
                showNotification('Ошибка доступа к микрофону');
                endCall();
            }
        }
        
        async function declineCall() {
            stopRingtone();
            incomingCallModal.classList.remove('active');
            await database.ref('calls/' + encodeURIComponent(currentUser)).update({ status: 'declined' });
            setTimeout(() => database.ref('calls/' + encodeURIComponent(currentUser)).remove(), 1000);
            currentCall = null;
        }
        
        async function endCall() {
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (remoteAudio) {
                remoteAudio.srcObject = null;
            }
            callModal.classList.remove('active');
            incomingCallModal.classList.remove('active');
            stopRingtone();
            
            if (currentCall) {
                const path = isCallInitiator ? 'calls/' + encodeURIComponent(currentCall.to) : 'calls/' + encodeURIComponent(currentUser);
                await database.ref(path).remove();
            }
            
            currentCall = null;
            isCallInitiator = false;
            isAudioMuted = false;
        }
        
        function showCallUI(name, type) {
            callName.textContent = name;
            callAvatar.textContent = name.charAt(0).toUpperCase();
            callVideos.style.display = 'none';
            callAudioOnly.style.display = 'flex';
            callModal.classList.add('active');
        }
        
        function toggleMute() {
            if (!localStream) return;
            const track = localStream.getAudioTracks()[0];
            if (track) {
                track.enabled = !track.enabled;
                isAudioMuted = !track.enabled;
                document.getElementById('call-mute-btn').classList.toggle('muted', isAudioMuted);
                document.getElementById('call-mute-icon').textContent = isAudioMuted ? '🎤❌' : '🎤';
            }
        }
        
        let ringtoneInterval = null;
        function playRingtone() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const ctx = new AudioContext();
                ringtoneInterval = setInterval(() => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.value = 440;
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.5);
                }, 1000);
            } catch (e) {}
        }
        
        function stopRingtone() {
            if (ringtoneInterval) {
                clearInterval(ringtoneInterval);
                ringtoneInterval = null;
            }
        }
        
        document.getElementById('audio-call-btn').addEventListener('click', startAudioCall);
        document.getElementById('call-accept-btn').addEventListener('click', acceptCall);
        document.getElementById('call-decline-btn').addEventListener('click', declineCall);
        document.getElementById('call-end-btn').addEventListener('click', endCall);
        document.getElementById('call-mute-btn').addEventListener('click', toggleMute);
        // Кнопка видео скрыта - только аудио звонки
        
        initCallListeners();
        
        // Test function to demonstrate the gift functionality
        function testGiftFunctionality() {
            console.log('Testing gift functionality:');
            console.log('- Users can send one free gift per day to any user');
            console.log('- Gifts are now free once per day');
            console.log('- Daily limits are tracked per user');
            console.log('- UI shows when daily limit is reached');
            console.log('- Received gifts section is hidden when user has no gifts');
            
            // Log current gift system status
            console.log('Gift types available:', Object.keys(giftTypes));
            console.log('Current user:', currentUser);
            
            if (currentUser) {
                const today = new Date().toDateString();
                const key = `${currentUser}_${today}`;
                const hasSentGiftToday = dailyGiftsTracker[key] && dailyGiftsTracker[key].count >= 1;
                console.log('Has sent gift today:', hasSentGiftToday);
                console.log('Daily tracker status:', dailyGiftsTracker[key]);
            }
        }
        
        // Run test on page load
        window.addEventListener('load', testGiftFunctionality);
    </script>
</body>
    <script>
        // Add event listeners for post field functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize any existing post fields
            const postTextareas = document.querySelectorAll('.post-field-textarea');
            
            postTextareas.forEach(textarea => {
                // Set up character counting
                const container = textarea.closest('.post-field-container');
                const charCounter = container.querySelector('.character-counter span');
                const maxLength = 500; // Default max length
                
                // Create character counter if it doesn't exist
                if (!charCounter) {
                    const counterDiv = document.createElement('div');
                    counterDiv.className = 'character-counter';
                    counterDiv.innerHTML = '<span>0</span>/' + maxLength;
                    container.appendChild(counterDiv);
                }
                
                textarea.addEventListener('input', function() {
                    const currentLength = this.value.length;
                    
                    // Update character counter
                    const counterSpan = container.querySelector('.character-counter span');
                    if (counterSpan) {
                        counterSpan.textContent = currentLength;
                    }
                    
                    // Update button state based on content
                    const postButton = container.querySelector('.post-field-button');
                    if (postButton) {
                        postButton.disabled = currentLength === 0;
                    }
                    
                    // Change counter color when approaching limit
                    const counterElement = container.querySelector('.character-counter');
                    if (currentLength > maxLength * 0.9) {
                        counterElement.style.color = '#e74c3c';
                    } else {
                        counterElement.style.color = 'var(--text-light)';
                    }
                    
                    // Auto-resize textarea
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 200) + 'px';
                });
                
                // Handle Enter key for submission (with Shift for new line)
                textarea.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        const postButton = container.querySelector('.post-field-button');
                        if (postButton && !postButton.disabled) {
                            postButton.click();
                        }
                    }
                });
            });
            
            // Add click handlers for post buttons
            const postButtons = document.querySelectorAll('.post-field-button');
            postButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const container = this.closest('.post-field-container');
                    const textarea = container.querySelector('.post-field-textarea');
                    if (textarea && textarea.value.trim()) {
                        // Here you would typically submit the post
                        console.log('Post submitted:', textarea.value);
                        
                        // Reset the textarea
                        textarea.value = '';
                        textarea.dispatchEvent(new Event('input'));
                        textarea.style.height = 'auto';
                        
                        // Show a confirmation or notification
                        const notification = document.createElement('div');
                        notification.className = 'notification show';
                        notification.textContent = 'Post published successfully!';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            notification.remove();
                        }, 3000);
                    }
                });
            });
            
            // Add click handlers for tools
            const postFieldTools = document.querySelectorAll('.post-field-tool');
            postFieldTools.forEach(tool => {
                tool.addEventListener('click', function() {
                    const title = this.getAttribute('title') || this.textContent;
                    console.log('Post tool clicked:', title);
                });
            });
        });
    </script>
</html>
